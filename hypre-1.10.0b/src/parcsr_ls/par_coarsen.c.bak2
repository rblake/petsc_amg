/*BHEADER**********************************************************************
 * (c) 1998   The Regents of the University of California
 *
 * See the file COPYRIGHT_and_DISCLAIMER for a complete copyright
 * notice, contact person, and disclaimer.
 *
 * $Revision: 2.15 $
 *********************************************************************EHEADER*/
/******************************************************************************
 *
 *****************************************************************************/

/* following should be in a header file */


#include "headers.h"
#include "limits.h"

// This struct is used in the parallel graph coloring routine (parColorGraph).
// Its purpose is to store information about all of the off-processor nodes.
// It stores the color of a node and also a list of that node's on-processor
// neighbors.
struct offd_node_color_and_neighbors {
  double rho; // random number used in the coloring algorithm to determine
           // precedence
  int color;
  int proc;
  hypre_Queue * ond_neighbor_list;
};
typedef struct offd_node_color_and_neighbors offdNodeAndNeighbors;


/*==========================================================================*/
/*==========================================================================*/
/**
  Selects a coarse "grid" based on the graph of a matrix.

  Notes:
  \begin{itemize}
  \item The underlying matrix storage scheme is a hypre_ParCSR matrix.
  \item The routine returns the following:
  \begin{itemize}
  \item S - a ParCSR matrix representing the "strength matrix".  This is
  used in the "build interpolation" routine.
  \item CF\_marker - an array indicating both C-pts (value = 1) and
  F-pts (value = -1)
  \end{itemize}
  \item We define the following temporary storage:
  \begin{itemize}
  \item measure\_array - an array containing the "measures" for each
  of the fine-grid points
  \item graph\_array - an array containing the list of points in the
  "current subgraph" being considered in the coarsening process.
  \end{itemize}
  \item The graph of the "strength matrix" for A is a subgraph of the
  graph of A, but requires nonsymmetric storage even if A is
  symmetric.  This is because of the directional nature of the
  "strengh of dependence" notion (see below).  Since we are using
  nonsymmetric storage for A right now, this is not a problem.  If we
  ever add the ability to store A symmetrically, then we could store
  the strength graph as floats instead of doubles to save space.
  \item This routine currently "compresses" the strength matrix.  We
  should consider the possibility of defining this matrix to have the
  same "nonzero structure" as A.  To do this, we could use the same
  A\_i and A\_j arrays, and would need only define the S\_data array.
  There are several pros and cons to discuss.
  \end{itemize}

  Terminology:
  \begin{itemize}
  \item Ruge's terminology: A point is "strongly connected to" $j$, or
  "strongly depends on" $j$, if $-a_ij >= \theta max_{l != j} \{-a_il\}$.
  \item Here, we retain some of this terminology, but with a more
  generalized notion of "strength".  We also retain the "natural"
  graph notation for representing the directed graph of a matrix.
  That is, the nonzero entry $a_ij$ is represented as: i --> j.  In
  the strength matrix, S, the entry $s_ij$ is also graphically denoted
  as above, and means both of the following:
  \begin{itemize}
  \item $i$ "depends on" $j$ with "strength" $s_ij$
  \item $j$ "influences" $i$ with "strength" $s_ij$
  \end{itemize}
  \end{itemize}

  {\bf Input files:}
  headers.h

  @return Error code.
  
  @param A [IN]
  coefficient matrix
  @param strength_threshold [IN]
  threshold parameter used to define strength
  @param S_ptr [OUT]
  strength matrix
  @param CF_marker_ptr [OUT]
  array indicating C/F points
  
  @see */
/*--------------------------------------------------------------------------*/

#define C_PT  1
#define F_PT -1
#define SF_PT -3
#define COMMON_C_PT  2
#define Z_PT -2

int
hypre_BoomerAMGCoarsen( hypre_ParCSRMatrix    *S,
                        hypre_ParCSRMatrix    *A,
                        int                    CF_init,
                        int                    debug_flag,
                        int                  **CF_marker_ptr)
{
   MPI_Comm 	       comm            = hypre_ParCSRMatrixComm(S);
   hypre_ParCSRCommPkg      *comm_pkg        = hypre_ParCSRMatrixCommPkg(S);
   hypre_ParCSRCommHandle   *comm_handle;

   hypre_CSRMatrix    *S_diag          = hypre_ParCSRMatrixDiag(S);
   int                *S_diag_i        = hypre_CSRMatrixI(S_diag);
   int                *S_diag_j        = hypre_CSRMatrixJ(S_diag);

   hypre_CSRMatrix    *S_offd          = hypre_ParCSRMatrixOffd(S);
   int                *S_offd_i        = hypre_CSRMatrixI(S_offd);
   int                *S_offd_j;

   int 		      *col_map_offd    = hypre_ParCSRMatrixColMapOffd(S);
   int                 num_variables   = hypre_CSRMatrixNumRows(S_diag);
   int		       col_1 = hypre_ParCSRMatrixFirstColDiag(S);
   int		       col_n = col_1 + hypre_CSRMatrixNumCols(S_diag);
   int 		       num_cols_offd = 0;
                  
   hypre_CSRMatrix    *S_ext;
   int                *S_ext_i;
   int                *S_ext_j;

   int		       num_sends = 0;
   int  	      *int_buf_data;
   double	      *buf_data;

   int                *CF_marker;
   int                *CF_marker_offd;
                      
   double             *measure_array;
   int                *graph_array;
   int                *graph_array_offd;
   int                 graph_size;
   int                 graph_offd_size;
   int                 global_graph_size;
                      
   int                 i, j, k, kc, jS, kS, ig, elmt;
   int		       index, start, my_id, num_procs, jrow, cnt;
                      
   int                 ierr = 0;
   int                 use_commpkg_A = 0;
   int                 break_var = 1;

   double	    wall_time;
   int   iter = 0;

#if 0 /* debugging */
   char  filename[256];
   FILE *fp;
   int   iter = 0;
#endif

   /*--------------------------------------------------------------
    * Compute a  ParCSR strength matrix, S.
    *
    * For now, the "strength" of dependence/influence is defined in
    * the following way: i depends on j if
    *     aij > hypre_max (k != i) aik,    aii < 0
    * or
    *     aij < hypre_min (k != i) aik,    aii >= 0
    * Then S_ij = 1, else S_ij = 0.
    *
    * NOTE: the entries are negative initially, corresponding
    * to "unaccounted-for" dependence.
    *----------------------------------------------------------------*/

   S_ext = NULL;
   if (debug_flag == 3) wall_time = time_getWallclockSeconds();
   MPI_Comm_size(comm,&num_procs);
   MPI_Comm_rank(comm,&my_id);

   if (!comm_pkg)
   {
        use_commpkg_A = 1;
        comm_pkg = hypre_ParCSRMatrixCommPkg(A); 
   }

   if (!comm_pkg)
   {
#ifdef HYPRE_NO_GLOBAL_PARTITION
        hypre_NewCommPkgCreate(A);
#else
        hypre_MatvecCommPkgCreate(A);
#endif
        comm_pkg = hypre_ParCSRMatrixCommPkg(A); 
   }

   num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);

   int_buf_data = hypre_CTAlloc(int, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
   buf_data = hypre_CTAlloc(double, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
 
   num_cols_offd = hypre_CSRMatrixNumCols(S_offd);

   S_diag_j = hypre_CSRMatrixJ(S_diag);

   if (num_cols_offd)
   {
      S_offd_j = hypre_CSRMatrixJ(S_offd);
   }
   /*----------------------------------------------------------
    * Compute the measures
    *
    * The measures are currently given by the column sums of S.
    * Hence, measure_array[i] is the number of influences
    * of variable i.
    *
    * The measures are augmented by a random number
    * between 0 and 1.
    *----------------------------------------------------------*/

   measure_array = hypre_CTAlloc(double, num_variables+num_cols_offd);

   for (i=0; i < S_offd_i[num_variables]; i++)
   { 
      measure_array[num_variables + S_offd_j[i]] += 1.0;
   }
   if (num_procs > 1)
   comm_handle = hypre_ParCSRCommHandleCreate(2, comm_pkg, 
                        &measure_array[num_variables], buf_data);

   for (i=0; i < S_diag_i[num_variables]; i++)
   { 
      measure_array[S_diag_j[i]] += 1.0;
   }

   if (num_procs > 1)
   hypre_ParCSRCommHandleDestroy(comm_handle);
      
   index = 0;
   for (i=0; i < num_sends; i++)
   {
      start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
      for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
            measure_array[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)]
                        += buf_data[index++];
   }

   for (i=num_variables; i < num_variables+num_cols_offd; i++)
   { 
      measure_array[i] = 0;
   }

   /* this augments the measures */
   if (CF_init == 2)
      hypre_BoomerAMGIndepSetInit(S, measure_array, 1);
   else
      hypre_BoomerAMGIndepSetInit(S, measure_array, 0);

   /*---------------------------------------------------
    * Initialize the graph array
    * graph_array contains interior points in elements 0 ... num_variables-1
    * followed by boundary values
    *---------------------------------------------------*/

   graph_array = hypre_CTAlloc(int, num_variables);
   if (num_cols_offd) 
      graph_array_offd = hypre_CTAlloc(int, num_cols_offd);
   else
      graph_array_offd = NULL;

   /* initialize measure array and graph array */

   for (ig = 0; ig < num_cols_offd; ig++)
      graph_array_offd[ig] = ig;

   /*---------------------------------------------------
    * Initialize the C/F marker array
    * C/F marker array contains interior points in elements 0 ... 
    * num_variables-1  followed by boundary values
    *---------------------------------------------------*/

   graph_offd_size = num_cols_offd;

   if (CF_init==1)
   {
      CF_marker = *CF_marker_ptr;
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
         if ( (S_offd_i[i+1]-S_offd_i[i]) > 0
                 || CF_marker[i] == -1)
         {
            CF_marker[i] = 0;
         }
         if ( CF_marker[i] == Z_PT)
         {
            if (measure_array[i] >= 1.0 ||
                (S_diag_i[i+1]-S_diag_i[i]) > 0)
            {
               CF_marker[i] = 0;
               graph_array[cnt++] = i;
            }
            else
            {
               CF_marker[i] = F_PT;
            }
         }
         else if (CF_marker[i] == SF_PT)
	    measure_array[i] = 0;
         else 
            graph_array[cnt++] = i;
      }
   }
   else
   {
      CF_marker = hypre_CTAlloc(int, num_variables);
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
	 CF_marker[i] = 0;
	 if ( (S_diag_i[i+1]-S_diag_i[i]) == 0 
		&& (S_offd_i[i+1]-S_offd_i[i]) == 0)
	 {
	    CF_marker[i] = SF_PT;
	    measure_array[i] = 0;
	 }
	 else
            graph_array[cnt++] = i;
      }
   }
   graph_size = cnt;
   if (num_cols_offd)
      CF_marker_offd = hypre_CTAlloc(int, num_cols_offd);
   else
      CF_marker_offd = NULL;
   for (i=0; i < num_cols_offd; i++)
	CF_marker_offd[i] = 0;
  
   /*---------------------------------------------------
    * Loop until all points are either fine or coarse.
    *---------------------------------------------------*/

   if (num_procs > 1)
   {
      if (use_commpkg_A)
         S_ext      = hypre_ParCSRMatrixExtractBExt(S,A,0);
      else
         S_ext      = hypre_ParCSRMatrixExtractBExt(S,S,0);
      S_ext_i    = hypre_CSRMatrixI(S_ext);
      S_ext_j    = hypre_CSRMatrixJ(S_ext);
   }

   /*  compress S_ext  and convert column numbers*/

   index = 0;
   for (i=0; i < num_cols_offd; i++)
   {
      for (j=S_ext_i[i]; j < S_ext_i[i+1]; j++)
      {
	 k = S_ext_j[j];
	 if (k >= col_1 && k < col_n)
	 {
	    S_ext_j[index++] = k - col_1;
	 }
	 else
	 {
	    kc = hypre_BinarySearch(col_map_offd,k,num_cols_offd);
	    if (kc > -1) S_ext_j[index++] = -kc-1;
	 }
      }
      S_ext_i[i] = index;
   }
   for (i = num_cols_offd; i > 0; i--)
      S_ext_i[i] = S_ext_i[i-1];
   if (num_procs > 1) S_ext_i[0] = 0;

   if (debug_flag == 3)
   {
      wall_time = time_getWallclockSeconds() - wall_time;
      printf("Proc = %d    Initialize CLJP phase = %f\n",
                     my_id, wall_time); 
   }

   while (1)
   {
      /*------------------------------------------------
       * Exchange boundary data, i.i. get measures and S_ext_data
       *------------------------------------------------*/

      if (num_procs > 1)
   	 comm_handle = hypre_ParCSRCommHandleCreate(2, comm_pkg, 
                        &measure_array[num_variables], buf_data);

      if (num_procs > 1)
   	 hypre_ParCSRCommHandleDestroy(comm_handle);
      
      index = 0;
      for (i=0; i < num_sends; i++)
      {
         start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
         for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
            measure_array[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)]
                        += buf_data[index++];
      }

      /*------------------------------------------------
       * Set F-pts and update subgraph
       *------------------------------------------------*/
 
      if (iter || (CF_init != 1))
      {
         for (ig = 0; ig < graph_size; ig++)
         {
            i = graph_array[ig];

            if ( (CF_marker[i] != C_PT) && (measure_array[i] < 1) )
            {
               /* set to be an F-pt */
               CF_marker[i] = F_PT;
 
	       /* make sure all dependencies have been accounted for */
               for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     CF_marker[i] = 0;
                  }
               }
               for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     CF_marker[i] = 0;
                  }
               }
            }
            if (CF_marker[i])
            {
               measure_array[i] = 0;
 
               /* take point out of the subgraph */
               graph_size--;
               graph_array[ig] = graph_array[graph_size];
               graph_array[graph_size] = i;
               ig--;
            }
         }
      }
 
      /*------------------------------------------------
       * Exchange boundary data, i.i. get measures 
       *------------------------------------------------*/

      if (debug_flag == 3) wall_time = time_getWallclockSeconds();

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
        {
            jrow = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
            buf_data[index++] = measure_array[jrow];
         }
      }

      if (num_procs > 1)
      { 
         comm_handle = hypre_ParCSRCommHandleCreate(1, comm_pkg, buf_data, 
        	&measure_array[num_variables]);
 
         hypre_ParCSRCommHandleDestroy(comm_handle);   
 
      } 
      /*------------------------------------------------
       * Debugging:
       *
       * Uncomment the sections of code labeled
       * "debugging" to generate several files that
       * can be visualized using the `coarsen.m'
       * matlab routine.
       *------------------------------------------------*/

#if 0 /* debugging */
      /* print out measures */
      sprintf(filename, "coarsen.out.measures.%04d", iter);
      fp = fopen(filename, "w");
      for (i = 0; i < num_variables; i++)
      {
         fprintf(fp, "%f\n", measure_array[i]);
      }
      fclose(fp);

      /* print out strength matrix */
      sprintf(filename, "coarsen.out.strength.%04d", iter);
      hypre_CSRMatrixPrint(S, filename);

      /* print out C/F marker */
      sprintf(filename, "coarsen.out.CF.%04d", iter);
      fp = fopen(filename, "w");
      for (i = 0; i < num_variables; i++)
      {
         fprintf(fp, "%d\n", CF_marker[i]);
      }
      fclose(fp);

      iter++;
#endif

      /*------------------------------------------------
       * Test for convergence
       *------------------------------------------------*/

      MPI_Allreduce(&graph_size,&global_graph_size,1,MPI_INT,MPI_SUM,comm);

      if (global_graph_size == 0)
         break;

      /*------------------------------------------------
       * Pick an independent set of points with
       * maximal measure.
       *------------------------------------------------*/
      if (iter || (CF_init != 1))
      {
         hypre_BoomerAMGIndepSet(S, measure_array, graph_array, 
				graph_size, 
				graph_array_offd, graph_offd_size, 
				CF_marker, CF_marker_offd);
         if (num_procs > 1)
         {
            comm_handle = hypre_ParCSRCommHandleCreate(12, comm_pkg,
                CF_marker_offd, int_buf_data);

            hypre_ParCSRCommHandleDestroy(comm_handle);
         }

         index = 0;
         for (i = 0; i < num_sends; i++)
         {
            start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
            for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg,i+1);j++)            {
               elmt = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
               if (!int_buf_data[index++] && CF_marker[elmt] > 0)
               {
                  CF_marker[elmt] = 0;
               }
            }
         }
      }

      iter++;
      /*------------------------------------------------
       * Exchange boundary data for CF_marker
       *------------------------------------------------*/


      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
        {
           elmt = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
          int_buf_data[index++] = CF_marker[elmt];
        }
      }

      if (num_procs > 1)
      {
         comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data, 
        	CF_marker_offd);
 
         hypre_ParCSRCommHandleDestroy(comm_handle);   
      }
 
      for (ig = 0; ig < graph_offd_size; ig++)
      {
         i = graph_array_offd[ig];

         if (CF_marker_offd[i] < 0)
         {
            /* take point out of the subgraph */
            graph_offd_size--;
            graph_array_offd[ig] = graph_array_offd[graph_offd_size];
            graph_array_offd[graph_offd_size] = i;
            ig--;
         }
      }
      if (debug_flag == 3)
      {
         wall_time = time_getWallclockSeconds() - wall_time;
         printf("Proc = %d  iter %d  comm. and subgraph update = %f\n",
                     my_id, iter, wall_time); 
      }
      /*------------------------------------------------
       * Set C_pts and apply heuristics.
       *------------------------------------------------*/

      for (i=num_variables; i < num_variables+num_cols_offd; i++)
      { 
         measure_array[i] = 0;
      }

      if (debug_flag == 3) wall_time = time_getWallclockSeconds();
      for (ig = 0; ig < graph_size; ig++)
      {
         i = graph_array[ig];

         /*---------------------------------------------
          * Heuristic: C-pts don't interpolate from
          * neighbors that influence them.
          *---------------------------------------------*/

         if (CF_marker[i] > 0)
         {  
            /* set to be a C-pt */
            CF_marker[i] = C_PT;

            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               j = S_diag_j[jS];
               if (j > -1)
               {
               
                  /* "remove" edge from S */
                  S_diag_j[jS] = -S_diag_j[jS]-1;
             
                  /* decrement measures of unmarked neighbors */
                  if (!CF_marker[j])
                  {
                     measure_array[j]--;
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               j = S_offd_j[jS];
               if (j > -1)
               {
             
                  /* "remove" edge from S */
                  S_offd_j[jS] = -S_offd_j[jS]-1;
               
                  /* decrement measures of unmarked neighbors */
                  if (!CF_marker_offd[j])
                  {
                     measure_array[j+num_variables]--;
                  }
               }
            }
         }
	 else
    	 {
            /* marked dependencies */
            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               j = S_diag_j[jS];
	       if (j < 0) j = -j-1;
   
               if (CF_marker[j] > 0)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_diag_j[jS] = -S_diag_j[jS]-1;
                  }
   
                  /* IMPORTANT: consider all dependencies */
                  /* temporarily modify CF_marker */
                  CF_marker[j] = COMMON_C_PT;
               }
               else if (CF_marker[j] == SF_PT)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_diag_j[jS] = -S_diag_j[jS]-1;
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               j = S_offd_j[jS];
	       if (j < 0) j = -j-1;
   
               if (CF_marker_offd[j] > 0)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_offd_j[jS] = -S_offd_j[jS]-1;
                  }
   
                  /* IMPORTANT: consider all dependencies */
                  /* temporarily modify CF_marker */
                  CF_marker_offd[j] = COMMON_C_PT;
               }
               else if (CF_marker_offd[j] == SF_PT)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_offd_j[jS] = -S_offd_j[jS]-1;
                  }
               }
            }
   
            /* unmarked dependencies */
            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               if (S_diag_j[jS] > -1)
               {
                  j = S_diag_j[jS];
   	          break_var = 1;
                  /* check for common C-pt */
                  for (kS = S_diag_i[j]; kS < S_diag_i[j+1]; kS++)
                  {
                     k = S_diag_j[kS];
		     if (k < 0) k = -k-1;
   
                     /* IMPORTANT: consider all dependencies */
                     if (CF_marker[k] == COMMON_C_PT)
                     {
                        /* "remove" edge from S and update measure*/
                        S_diag_j[jS] = -S_diag_j[jS]-1;
                        measure_array[j]--;
                        break_var = 0;
                        break;
                     }
                  }
   		  if (break_var)
                  {
                     for (kS = S_offd_i[j]; kS < S_offd_i[j+1]; kS++)
                     {
                        k = S_offd_j[kS];
		        if (k < 0) k = -k-1;
   
                        /* IMPORTANT: consider all dependencies */
                        if ( CF_marker_offd[k] == COMMON_C_PT)
                        {
                           /* "remove" edge from S and update measure*/
                           S_diag_j[jS] = -S_diag_j[jS]-1;
                           measure_array[j]--;
                           break;
                        }
                     }
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               if (S_offd_j[jS] > -1)
               {
                  j = S_offd_j[jS];
   
                  /* check for common C-pt */
                  for (kS = S_ext_i[j]; kS < S_ext_i[j+1]; kS++)
                  {
                     k = S_ext_j[kS];
   	             if (k >= 0)
   		     {
                        /* IMPORTANT: consider all dependencies */
                        if (CF_marker[k] == COMMON_C_PT)
                        {
                           /* "remove" edge from S and update measure*/
                           S_offd_j[jS] = -S_offd_j[jS]-1;
                           measure_array[j+num_variables]--;
                           break;
                        }
                     }
   		     else
   		     {
   		        kc = -k-1;
   		        if (kc > -1 && CF_marker_offd[kc] == COMMON_C_PT)
   		        {
                           /* "remove" edge from S and update measure*/
                           S_offd_j[jS] = -S_offd_j[jS]-1;
                           measure_array[j+num_variables]--;
                           break;
   		        }
   		     }
                  }
               }
            }
         }

         /* reset CF_marker */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
	 {
            j = S_diag_j[jS];
	    if (j < 0) j = -j-1;

            if (CF_marker[j] == COMMON_C_PT)
            {
               CF_marker[j] = C_PT;
            }
         }
         for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
         {
            j = S_offd_j[jS];
	    if (j < 0) j = -j-1;

            if (CF_marker_offd[j] == COMMON_C_PT)
            {
               CF_marker_offd[j] = C_PT;
            }
         }
      }
      if (debug_flag == 3)
      {
         wall_time = time_getWallclockSeconds() - wall_time;
         printf("Proc = %d    CLJP phase = %f graph_size = %d nc_offd = %d\n",
                     my_id, wall_time, graph_size, num_cols_offd); 
      }
   }

   /*---------------------------------------------------
    * Clean up and return
    *---------------------------------------------------*/

   /* Reset S_matrix */
   for (i=0; i < S_diag_i[num_variables]; i++)
   {
      if (S_diag_j[i] < 0)
         S_diag_j[i] = -S_diag_j[i]-1;
   }
   for (i=0; i < S_offd_i[num_variables]; i++)
   {
      if (S_offd_j[i] < 0)
         S_offd_j[i] = -S_offd_j[i]-1;
   }
   /*for (i=0; i < num_variables; i++)
      if (CF_marker[i] == SF_PT) CF_marker[i] = F_PT;*/

   hypre_TFree(measure_array);
   hypre_TFree(graph_array);
   if (num_cols_offd) hypre_TFree(graph_array_offd);
   hypre_TFree(buf_data);
   hypre_TFree(int_buf_data);
   hypre_TFree(CF_marker_offd);
   if (num_procs > 1) hypre_CSRMatrixDestroy(S_ext);

   *CF_marker_ptr   = CF_marker;

   return (ierr);
}

double hash(unsigned int key)
{
  key += ~(key << 15);
  key ^=  (key >> 10);
  key +=  (key << 3);
  key ^=  (key >> 6);
  key += ~(key << 11);
  key ^=  (key >> 16);
  return ((double)key)/UINT_MAX;
}

void setRhoValues(double * rho_array, int * V_i_S, int V_i_S_size, 
		  int V_ghost_S_size, hypre_ParCSRMatrix * S, int my_id)
{
  int i;
  int * V_ghost_S = hypre_ParCSRMatrixColMapOffd(S);
  int * row_starts = hypre_ParCSRMatrixRowStarts(S);

  // First, initialize the rho values for the on-processor nodes.
  for(i = 0; i < V_i_S_size; i++) {
    rho_array[i] = hash(V_i_S[i]+row_starts[my_id]);
  }

  // Second, initialize the rho values for the off-processor nodes.
  for(i = 0; i < V_ghost_S_size; i++) {
    rho_array[i+V_i_S_size] = hash(V_ghost_S[i]);
  }

/*   hypre_SeedRand(2747+my_id); */
/*   for(i = 0; i < local_rho_array_length; i++) { */
/*     rho_array[i] = hypre_Rand(); */
/*   } */
}

void setRhoValuesOnd(double * ond_rho, int ond_to_offd_count, int * V_i_S,
		     int row_starts)
{
  int i, rand_index;

  rand_index = 0;
  hypre_SeedRand(2747);
  for (i = 0; i < ond_to_offd_count; i++) {
    while(V_i_S[i]+row_starts > rand_index) {
      hypre_Rand();
      rand_index++;
    }
    ond_rho[i] = hypre_Rand();
    rand_index++;
  }
}

void setRhoValuesOffd(offdNodeAndNeighbors * offd_rho, int offd_count, int * S_offd_map)
{
  int i, rand_index;

  rand_index = 0;
  hypre_SeedRand(2747);
  for (i = 0; i < offd_count; i++) {
    while(S_offd_map[i] > rand_index) {
      hypre_Rand();
      rand_index++;
    }
    offd_rho[i].rho = hypre_Rand();
    rand_index++;
  }
}

void colorQueue(hypre_ParCSRMatrix * S, short * color_array,
		offdNodeAndNeighbors * offd_rho, hypre_Queue * color_queue,
      	        int * num_colors, hypre_Queue ** send_queue, int * proc_list,
	        int ** proc_send_list, int * proc_send_list_ind,
		int proc_count, int * packed, int * V_i_S)
{
  hypre_CSRMatrix *S_diag, *S_offd;
  int *S_diag_i, *S_diag_j, *S_offd_i, *S_offd_j, *data, *used_colors;
  int i, my_id, row_start, n_colored, curr_node, V_i_S_ind;
  int used_colors_ind, curr_choice, proc_ind;
  MPI_Comm comm = hypre_ParCSRMatrixComm(S);

  MPI_Comm_rank(comm,&my_id);

  S_diag = hypre_ParCSRMatrixDiag(S);
  S_diag_i = hypre_CSRMatrixI(S_diag);
  S_diag_j = hypre_CSRMatrixJ(S_diag);

  S_offd = hypre_ParCSRMatrixOffd(S);
  S_offd_i = hypre_CSRMatrixI(S_offd);
  S_offd_j = hypre_CSRMatrixJ(S_offd);

  row_start = hypre_ParCSRMatrixRowStarts(S)[my_id];

  for(i = 0; i < proc_count; i++)
    packed[i] = 0;

  n_colored = 0;
  // Color each of the nodes in the color_queue.
  while(color_queue->head) {
    data = dequeue(color_queue);
    V_i_S_ind = *data;
    curr_node = V_i_S[V_i_S_ind];
    hypre_TFree(data);

    used_colors = hypre_CTAlloc(int, S_diag_i[curr_node+1]-S_diag_i[curr_node] + S_offd_i[curr_node+1]-S_offd_i[curr_node]);
    used_colors_ind = 0;
    // Check the on-processor neighbors.
    for(i = S_diag_i[curr_node]; i < S_diag_i[curr_node+1]; i++) {
      if(color_array[S_diag_j[i]] > 0) {
	// Then this node has been colored.
	used_colors[used_colors_ind] = color_array[S_diag_j[i]];
	used_colors_ind++;
      }
    }

    // Check the off-processor neighbors.
    for(i = S_offd_i[curr_node]; i < S_offd_i[curr_node+1]; i++) {
      if(offd_rho[S_offd_j[i]].color > 0) {
	// Then this node has been colored.
	used_colors[used_colors_ind] = offd_rho[S_offd_j[i]].color;
	used_colors_ind++;
      }
    }

    qsort0(used_colors, 0, used_colors_ind-1);

    // Now search the used_colors array to find the lowest number > 0 that
    // does not appear. Make that number the color of curr_node.
    curr_choice = 1;
    for(i = 0; i < used_colors_ind; i++) {
      if(used_colors[i] == curr_choice)
	// Then the current choice of color is in use. Pick the next one up.
	curr_choice++;
      else if(used_colors[i] > curr_choice)
	// The current choice of color is available. Exit the loop and color
	// curr_node this color.
	i = used_colors_ind; // to break loop
    }
    color_array[curr_node] = curr_choice;
    if(curr_choice > *num_colors)
      *num_colors = curr_choice;
    hypre_TFree(used_colors);

    // Now pack up the sends for this node.
    while(send_queue[V_i_S_ind]->head) {
      data = dequeue(send_queue[V_i_S_ind]);
      proc_ind = hypre_BinarySearch(proc_list, data[1], proc_count);
      proc_send_list[proc_ind][proc_send_list_ind[proc_ind]] = data[0];
      proc_send_list[proc_ind][proc_send_list_ind[proc_ind]+1] = curr_node+row_start;
      proc_send_list[proc_ind][proc_send_list_ind[proc_ind]+2] = curr_choice;
      proc_send_list_ind[proc_ind] += 3;
      packed[proc_ind]++;

      hypre_TFree(data);
    }
  }
}

int procLookup(hypre_ParCSRMatrix * S, int node, int prev_proc)
{
  int ind;
  int proc = 0;
  int * row_starts = hypre_ParCSRMatrixRowStarts(S);

  if(row_starts[prev_proc] <= node && row_starts[prev_proc+1] > node)
    return prev_proc;

  ind = 1;
  while(row_starts[ind] <= node) {
    proc++;
    ind++;
  }
  return proc;
}

int waitforLoopData(hypre_ParCSRCommHandle * comm_handle, hypre_ParCSRCommPkg * comm_pkg)
{
  MPI_Status *status0;
  int ierr = 0;
MPI_Comm comm = hypre_ParCSRCommPkgComm(comm_pkg);
int my_id; MPI_Comm_rank(comm, &my_id);

  if ( comm_handle==NULL ) return ierr;
  if (hypre_ParCSRCommHandleNumRequests(comm_handle)) {
    status0 = hypre_CTAlloc(MPI_Status,
			    hypre_ParCSRCommHandleNumRequests(comm_handle));
/* MPI_Barrier(comm); */
/* printf("hihi3 %d\n", my_id); */
/* MPI_Barrier(comm); */
    MPI_Waitall(hypre_ParCSRCommHandleNumRequests(comm_handle),
		hypre_ParCSRCommHandleRequests(comm_handle), status0);
    hypre_TFree(status0);
  }

  hypre_TFree(hypre_ParCSRCommHandleRequests(comm_handle));
  hypre_TFree(comm_handle);
}

int sendLoopData(hypre_ParCSRCommPkg * comm_pkg,
		 int * color_send_buf,
		 int finished,
		 int just_finished,
		 int local_num_colors,
		 int * ghost_color_array,
		 int * neighborhood_finished,
		 int * neighborhood_num_colors,
		 int * num_finished_neighbors,
		 int * finished_neighbors_array)
{
  int num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);
  int num_recvs = hypre_ParCSRCommPkgNumRecvs(comm_pkg);
  MPI_Comm comm = hypre_ParCSRCommPkgComm(comm_pkg);

  hypre_ParCSRCommHandle *comm_handle;
  int num_requests;
  MPI_Request *requests;
  int * neighbor_num_colors = hypre_CTAlloc(int, num_recvs);

  int i, j;
  int ip, vec_start, vec_len, ierr;
int my_id; MPI_Comm_rank(comm, &my_id);

/*   num_sends -= *num_finished_neighbors; */
/*   //if(finished) */
/*   //num_recvs = 0; */
/*   if(finished && !just_finished) */
/*     num_recvs = 0; */

/* MPI_Barrier(comm); */
/* printf("hihi %d\n", my_id); */
/* MPI_Barrier(comm); */

/*   num_requests = num_sends + num_recvs; */
/*   requests = hypre_CTAlloc(MPI_Request, num_requests); */
/*   j = 0; */

/*   for (i = 0; i < num_recvs; i++) { */
/*     ip = hypre_ParCSRCommPkgRecvProc(comm_pkg, i);  */
/*     MPI_Irecv(&finished_neighbors_array[i], 1, MPI_INT, ip, 0, comm, &requests[j++]); */
/*   } */
/*   for (i = 0; i < num_sends; i++) { */
/*     if(!finished_neighbors_array[i]) { */
/*       ip = hypre_ParCSRCommPkgSendProc(comm_pkg, i);  */
/*       MPI_Isend(&finished, 1, MPI_INT, ip, 0, comm, &requests[j++]); */
/*     } */
/*   } */

/*   comm_handle = hypre_CTAlloc(hypre_ParCSRCommHandle, 1); */
/*   hypre_ParCSRCommHandleCommPkg(comm_handle) = comm_pkg; */
/*   //hypre_ParCSRCommHandleSendData(comm_handle) = &finished; */
/*   //hypre_ParCSRCommHandleRecvData(comm_handle) = finished_neighbors_array; */
/*   hypre_ParCSRCommHandleNumRequests(comm_handle) = num_requests; */
/*   hypre_ParCSRCommHandleRequests(comm_handle) = requests; */

/*   ierr = waitforLoopData(comm_handle, comm_pkg); */
/* MPI_Barrier(comm); */
/* printf("hihi2 %d\n", my_id); */
/* MPI_Barrier(comm); */

/*   // Process the received information. */
/*   *neighborhood_finished = 1; */
/*   *num_finished_neighbors = 0; */
/*   for(i = 0; i < num_recvs; i++) { */

/*     // Check if neighbors are finished. */
/*     if(finished_neighbors_array[i] == 0) */
/*       *neighborhood_finished = 0; */
/*     else */
/*       *num_finished_neighbors++; */
/*   } */

//num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);
//num_sends -= *num_finished_neighbors;
//num_recvs -= *num_finished_neighbors;

  num_requests = (3*(num_sends-*num_finished_neighbors)) +
    (3*(num_recvs-*num_finished_neighbors));
  requests = hypre_CTAlloc(MPI_Request, num_requests);
  j = 0;

if(my_id > -1) {
  printf("%d -> %d: ", my_id, num_recvs);
  for(i = 0; i < num_recvs; i++)
    if(!finished_neighbors_array[i])
      printf("%d ", hypre_ParCSRCommPkgRecvProc(comm_pkg, i));
  printf("\n");
  printf("%d -> %d: ", my_id, num_sends);
  for(i = 0; i < num_sends; i++)
    if(!finished_neighbors_array[i])
      printf("%d ", hypre_ParCSRCommPkgSendProc(comm_pkg, i)); 
  printf("\n");
}

  for (i = 0; i < num_recvs; i++) {
    if(!finished_neighbors_array[i]) {
      ip = hypre_ParCSRCommPkgRecvProc(comm_pkg, i); 
      vec_start = hypre_ParCSRCommPkgRecvVecStart(comm_pkg,i);
      vec_len = hypre_ParCSRCommPkgRecvVecStart(comm_pkg,i+1)-vec_start;
      MPI_Irecv(&ghost_color_array[vec_start], vec_len, MPI_INT,
		ip, 0, comm, &requests[j++]);
      MPI_Irecv(&finished_neighbors_array[i], 1, MPI_INT, ip, 1, comm, &requests[j++]);
      MPI_Irecv(&neighbor_num_colors[i], 1, MPI_INT, ip, 2, comm, &requests[j++]);
    }
  }
  for (i = 0; i < num_sends; i++) {
    if(!finished_neighbors_array[i]) {
      vec_start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
      vec_len = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1)-vec_start;
      ip = hypre_ParCSRCommPkgSendProc(comm_pkg, i); 
      MPI_Isend(&color_send_buf[vec_start], vec_len, MPI_INT,
		ip, 0, comm, &requests[j++]);
      MPI_Isend(&finished, 1, MPI_INT, ip, 1, comm, &requests[j++]);
      MPI_Isend(&local_num_colors, 1, MPI_INT, ip, 2, comm, &requests[j++]);
    }
  }

  comm_handle = hypre_CTAlloc(hypre_ParCSRCommHandle, 1);
  hypre_ParCSRCommHandleCommPkg(comm_handle) = comm_pkg;
  //hypre_ParCSRCommHandleSendData(comm_handle) = color_send_buf;
  //hypre_ParCSRCommHandleRecvData(comm_handle) = ghost_color_array;
  hypre_ParCSRCommHandleNumRequests(comm_handle) = num_requests;
  hypre_ParCSRCommHandleRequests(comm_handle) = requests;

if(num_requests == 0)  printf("uh huh! %d\n", my_id);
  ierr = waitforLoopData(comm_handle, comm_pkg);

  // Process the received information.
  *neighborhood_finished = 1;
  *num_finished_neighbors = 0;
  for(i = 0; i < num_recvs; i++) {

    // Check if neighbors are finished.
    if(finished_neighbors_array[i] == 0)
      *neighborhood_finished = 0; 
    else
      *num_finished_neighbors++;

    // Check if neighbor's num_colors is greatest known num_colors.
    if(*neighborhood_num_colors < neighbor_num_colors[i])
      *neighborhood_num_colors = neighbor_num_colors[i];
  }

  hypre_TFree(neighbor_num_colors);

/* MPI_Barrier(comm); */
/* printf("byebye %d\n", my_id); */
/* MPI_Barrier(comm); */
  return ierr;
}

void seqColorGraphNewAgain(hypre_ParCSRMatrix * S, short * color_array, int * num_colors, int * V_i_S, int V_i_S_len, int level);  /////////DELETE ME!!!!!!!!!!!!!!!

void parColorGraphNew(hypre_ParCSRMatrix * S, hypre_ParCSRMatrix * A, short * color_array, int * num_colors, int level)
{
#define QUEUED        -1
#define UNCOLORED     0

//printf("in\n");

  hypre_ParCSRCommHandle * comm_handle;
  hypre_ParCSRCommPkg * comm_pkg = hypre_ParCSRMatrixCommPkg(S);
  MPI_Comm comm = hypre_ParCSRMatrixComm(S);

  // Get pointers to parts of the strength matrix
  hypre_CSRMatrix *S_diag, *S_offd;
  int *S_diag_i, *S_diag_j, *S_offd_i, *S_offd_j, *S_offd_map;
  S_diag = hypre_ParCSRMatrixDiag(S);
  S_diag_i = hypre_CSRMatrixI(S_diag);
  S_diag_j = hypre_CSRMatrixJ(S_diag);
  S_offd = hypre_ParCSRMatrixOffd(S);
  S_offd_i = hypre_CSRMatrixI(S_offd);
  S_offd_j = hypre_CSRMatrixJ(S_offd);
  S_offd_map = hypre_ParCSRMatrixColMapOffd(S);
  int * V_i_S;
  int V_i_S_size, V_ghost_S_size, color_send_buf_size;
  int num_finished_neighbors, *finished_neighbors_array;

  int num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);
  int num_recvs = hypre_ParCSRCommPkgNumRecvs(comm_pkg);
  finished_neighbors_array = hypre_CTAlloc(int, num_sends);
  num_finished_neighbors = 0;
  int my_id;

  int i, j, k, row_index, local_num_colors, num_colored, *used_colors, nodeID;
  short ready_to_color, color_assigned;

  double * rho_array;
  int *ghost_color_array, *color_send_buf, *color_send_map;

  MPI_Comm_rank(comm, &my_id);
  int finished, just_finished, neighborhood_finished;
  local_num_colors = 0;
  *num_colors = 0;

int num_variables = hypre_CSRMatrixNumRows(S_offd);
int bound_count = 0;
for(i = 0; i < num_variables; i++) {
  if(S_offd_i[i] != S_offd_i[i+1])
    bound_count++;
}
printf("%d: %d %d\n", my_id, hypre_CSRMatrixNumRownnz(S_offd), bound_count);

  // Initialize the pseudo-random numbers on V_i^S.
  //    First, determine nodes and number of nodes in V_i^S.
  //V_i_S_size = hypre_ParCSRCommPkgSendMapStart(comm_pkg, num_sends) -
  //  hypre_ParCSRCommPkgSendMapStart(comm_pkg, 0);
  V_i_S_size = hypre_CSRMatrixNumRownnz(S_offd); // Number of empty
						 // rows in S_offd.
  V_i_S = hypre_CSRMatrixRownnz(S_offd);

  V_ghost_S_size = hypre_ParCSRCommPkgRecvVecStart(comm_pkg, num_recvs) -
    hypre_ParCSRCommPkgRecvVecStart(comm_pkg, 0);
  // Is the above the same as hypre_CSRMatrixNumCols(S_offd)?

  printf("I am processor %d, and I have %d nodes on the processor boundary and %d ghost nodes.\n", my_id, V_i_S_size, V_ghost_S_size);

  //    Second, declare array to hold pseudo-random numbers, including those
  //    from the ghost points.
  rho_array = hypre_CTAlloc(double, V_i_S_size+V_ghost_S_size);

  //    Third, initialize the pseudo-random numbers corresponding to nodes on
  //    this processor and the nodes on neighboring processors.
  //
  //    Since each processor can compute the "random" number for all
  //    of the off-processor nodes, no communication is needed to
  //    exchange rho values.
  setRhoValues(rho_array, V_i_S, V_i_S_size, V_ghost_S_size, S, my_id);

  // Initialize the ghost_color_array. hypre_CTAlloc automatically
  // initializes each entry to be UNCOLORED. This stores the colors of
  // the ghost points.
  ghost_color_array = hypre_CTAlloc(int, V_ghost_S_size);

  // Initialize the color_send_buf. This is where color values to be
  // sent to other processors are gathered.
  color_send_buf_size = hypre_ParCSRCommPkgSendMapStart(comm_pkg, num_sends) -
    hypre_ParCSRCommPkgSendMapStart(comm_pkg, 0);
  color_send_buf = hypre_CTAlloc(int, color_send_buf_size);

  // Continue looping until all local nodes in V_i^S are colored.
  num_colored = 0;
  finished = 0;
  while(num_colored < V_i_S_size) {
    //MPI_Allreduce(&finished, &global_finished, 1, MPI_INT, MPI_MIN, comm);
    for(i = 0; i < V_i_S_size; i++) {
      nodeID = V_i_S[i];
      if(color_array[nodeID] == UNCOLORED) {
	// Check if this node is now eligible to be colored.
	// This depends solely on the weights of the neighboring ghost
	// points.
	ready_to_color = 1;
	for(j = S_offd_i[nodeID]; j < S_offd_i[nodeID+1]; j++) {
	  if(ghost_color_array[S_offd_j[j]] == UNCOLORED &&
	     rho_array[S_offd_j[j]+V_i_S_size] > rho_array[i]) {
	    // Then i is not ready to be colored yet.
	    ready_to_color = 0;
	    j = S_offd_i[nodeID+1]; // <-- to break the loop
	  }
	}

	if(ready_to_color) {
	  // Color this node.
	  if(local_num_colors == 0) {
	    // Trivial case. Nothing has been colored yet, so this
	    // automatically becomes "color" 1.
	    color_array[nodeID] = 1;
	    local_num_colors = 1;
	    *num_colors = 1;
	  }
	  else {
	    // Figure out the colors of i's neighbors (on- and
	    // off-processor).
	    used_colors = hypre_CTAlloc(int, *num_colors);
	    for(j = S_diag_i[nodeID]; j < S_diag_i[nodeID+1]; j++) {
	      // check on-processor neighbors
	      if(color_array[S_diag_j[j]] != UNCOLORED) {
		used_colors[color_array[S_diag_j[j]]-1] = 1;
		if(color_array[S_diag_j[j]]-1 > *num_colors-1)
		  printf("OH CRAPP\n");
	      }
	    }

	    for(j = S_offd_i[nodeID]; j < S_offd_i[nodeID+1]; j++) {
	      // check off-processor neighbors
	      if(ghost_color_array[S_offd_j[j]] != UNCOLORED) {
		used_colors[ghost_color_array[S_offd_j[j]]-1] = 1;
		if(ghost_color_array[S_offd_j[j]]-1 > *num_colors-1)
		  printf("OH CRAP!\n");
		if(S_offd_j[j] > V_ghost_S_size)
		  printf("HUH?!\n");
	      }
	    }

	    // Now all used colors have been found. Identify the
	    // smallest available color and assign it.
	    color_assigned = 0;
	    for(j = 0; j < *num_colors; j++) {
	      if(used_colors[j] == 0) {
		// Assign this color.
		color_array[nodeID] = j+1;
		if(j+1 > local_num_colors)
		  local_num_colors = j+1;
		color_assigned = 1;
		j = *num_colors; // <-- to break the loop
	      }
	    }
	    if(!color_assigned) { // then a new largest color is
				  // needed
	      color_array[nodeID] = *num_colors + 1;
	      *num_colors = *num_colors + 1;
	      local_num_colors = *num_colors;
	    }

	    hypre_TFree(used_colors);
	  }
	  num_colored++;
	}
      }
    }
    // Exchange color information with neighboring processors. Load
    // information into the color_send_buf first.
    color_send_map = hypre_ParCSRCommPkgSendMapElmts(comm_pkg);
    for(i = 0; i < color_send_buf_size; i++) {
      color_send_buf[i] = color_array[color_send_map[i]];
    }

    sendLoopData(comm_pkg, color_send_buf, finished, 0, local_num_colors,
		 ghost_color_array, &neighborhood_finished, num_colors, 
		 &num_finished_neighbors, finished_neighbors_array);


    //comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, color_send_buf,
    //ghost_color_array);
    //hypre_ParCSRCommHandleDestroy(comm_handle);
    //MPI_Allreduce(&local_num_colors, num_colors, 1, MPI_INT, MPI_MAX, comm);
//printf("%d made it out with %d colors.\n", my_id, *num_colors);
  }
  finished = 1;
  just_finished = 1;
printf("%d here! %d colored %d %d\n", my_id, num_colored, finished,
       neighborhood_finished);

  //MPI_Allreduce(&finished, &global_finished, 1, MPI_INT, MPI_MIN, comm);

  //while(!neighborhood_finished) { // some processors still need the
			    // information sent
    sendLoopData(comm_pkg, color_send_buf, finished, just_finished,
		 local_num_colors, ghost_color_array, &neighborhood_finished,
		 num_colors, &num_finished_neighbors,
		 finished_neighbors_array);
    just_finished = 0;

    //comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, color_send_buf,
    //ghost_color_array);
    //hypre_ParCSRCommHandleDestroy(comm_handle);
    //MPI_Allreduce(&local_num_colors, num_colors, 1, MPI_INT, MPI_MAX, comm);
    //MPI_Allreduce(&finished, &global_finished, 1, MPI_INT, MPI_MIN, comm);
    //}
  *num_colors = local_num_colors;
  printf("%d movin' out! %d\n", my_id, *num_colors);

  hypre_TFree(rho_array);
  hypre_TFree(ghost_color_array);
  hypre_TFree(color_send_buf);
  hypre_TFree(finished_neighbors_array);

  WriteCoarseningColorInformation(S, color_array, level);
  //seqColorGraphNewAgain(A, color_array, num_colors, V_i_S, V_i_S_size, level); //DELETE ME AND THE DECLARTION ABOVE THIS FUNCTION!!!!!!!!!!!!!!!!!!!!

  printf("out %d\n", my_id);
}

/** This routine implements the parallel graph coloring algorithm given in Figure 6 of the Jones and Plassmann paper "A Parallel Graph Coloring Heuristic".
 *
 * This code will use as much of the same notation as the pseudocode in the paper as possible.
 *
 * @param S a hypre_ParCSRMatrix object containing the strength matrix of the linear system A.
 * @param color_array [OUT] an array of shorts containing color of each node.
 * @param num_colors a pointer to an integer storing the total number of colors in the graph.
 */
void parColorGraph(hypre_ParCSRMatrix * S, hypre_ParCSRMatrix * A, short * color_array, int * num_colors, int level)
{
  hypre_CSRMatrix *S_diag, *S_offd;
  int *S_diag_i, *S_diag_j, *S_offd_i, *S_offd_j, *S_offd_map, *global_ind, *local_ind;
  int *temp_local_ind, temp_local_ind_count;
  int *temp_proc_list, proc_count, *proc_list;
  int *proc_send_count_list = NULL;
  int *proc_recv_count_list = NULL;
  int **proc_send_list, *proc_send_list_ind, *packed;
  int **proc_recv_list, *proc_recv_list_ind;
  int *data, *V_i_S, *n_wait;
  int i, j, num_rows, offd_count, local_i, ond_to_offd_count, row_starts;
  int my_id, n_colored, last_proc, msg_size;
  double *ond_rho;
  offdNodeAndNeighbors * offd_rho;
  hypre_Queue *color_queue, **send_queue;
  hypre_QueueElement * curr_el;
  MPI_Request request;
  MPI_Status status;
  MPI_Comm comm = hypre_ParCSRMatrixComm(S);

  MPI_Comm_rank(comm,&my_id);

  S_diag = hypre_ParCSRMatrixDiag(S);
  S_diag_i = hypre_CSRMatrixI(S_diag);
  S_diag_j = hypre_CSRMatrixJ(S_diag);

  S_offd = hypre_ParCSRMatrixOffd(S);
  S_offd_i = hypre_CSRMatrixI(S_offd);
  S_offd_j = hypre_CSRMatrixJ(S_offd);
  S_offd_map = hypre_ParCSRMatrixColMapOffd(S);

  num_rows = hypre_CSRMatrixNumRows(S_diag);
  offd_count = hypre_CSRMatrixNumCols(S_offd);
  row_starts = hypre_ParCSRMatrixRowStarts(S)[my_id];

  // Begin setting up the data structures to keep track of the off-processor nodes that
  // will be important for the parallel phase of this algorithm.
  //
  // First, initialize the data structure used to store information about the
  // off-processor neighbors.
  offd_rho = hypre_CTAlloc(offdNodeAndNeighbors, offd_count);
  global_ind = hypre_CTAlloc(int, offd_count);
  local_ind = hypre_CTAlloc(int, offd_count);
  temp_proc_list = hypre_CTAlloc(int, offd_count);
  last_proc = 0;
  for(i = 0; i < offd_count; i++) {
    offd_rho[i].rho = 0;
    offd_rho[i].color = 0;
    offd_rho[i].proc = procLookup(S, S_offd_map[i], last_proc);
    last_proc = offd_rho[i].proc;
    temp_proc_list[i] = last_proc;
    offd_rho[i].ond_neighbor_list = newQueue();

    global_ind[i] = S_offd_map[i];
    local_ind[i] = i;
  }

  // After the sorting command below, it will be possible to find the local index
  // using the global node number of an off-processor node by doing a binary search
  // of global_ind. This local index is useful for looking at S_offd columns.
  hypre_qsort2i(global_ind, local_ind, 0, offd_count-1);

  // Gather information on all of the processors that are home to adjacent
  // off-processor nodes.
  qsort0(temp_proc_list, 0, offd_count-1);
  // count the number of unique processors
  proc_count = 0;
  last_proc = -1;
  for(i = 0; i < offd_count; i++) {
    if(last_proc < temp_proc_list[i]) {
      last_proc = temp_proc_list[i];
      proc_count++;
    }
  }
  proc_list = hypre_CTAlloc(int, proc_count);
  proc_count = 0;
  last_proc = -1;
  for(i = 0; i < offd_count; i++) {
    if(last_proc < temp_proc_list[i]) {
      last_proc = temp_proc_list[i];
      proc_list[proc_count] = last_proc;
      proc_count++;
    }
  }
  hypre_TFree(temp_proc_list);
  

  // DELETE THIS WHEN THE WHOLE THING IS DONE AND WORKING PROPERLY.
  for(i = 0; i < offd_count; i++) {
    if(global_ind[i] != S_offd_map[local_ind[i]])
      printf("hey!!!!!\n");
  }
  /////////////////////////////////////////////////////////////

  // Now go through the off-processor connections in the matrix and record to which
  // local node each non-local node connects.
  temp_local_ind = hypre_CTAlloc(int, num_rows); // used to get all of the unique local
                                            // nodes that have off-processor connections
  temp_local_ind_count = 0;
  for(i = 0; i < num_rows; i++) {
    if(S_offd_i[i] < S_offd_i[i+1]) {
      temp_local_ind[i] = 1;
      temp_local_ind_count++;
    }
    for(j = S_offd_i[i]; j < S_offd_i[i+1]; j++) {
      // S_offd_map[S_offd_j[j]] is the off-processor node's global number.
      local_i = local_ind[hypre_BinarySearch(global_ind, S_offd_map[S_offd_j[j]], offd_count)];
      data = hypre_CTAlloc(int, 1);
      *data = i;
      enqueueData(data, offd_rho[local_i].ond_neighbor_list);
    }
  }

  // Determine V_i^S (the vertices on this processor who share at least one
  // edge with a vertex on another processor).
  //
  // Basically all of the nodes in the set V_i^s are the nodes that have a
  // row of data in the S_offd matrix. This information is already in
  // temp_local_ind and just needs to be extracted.
  ond_to_offd_count = temp_local_ind_count;
  V_i_S = hypre_CTAlloc(int, ond_to_offd_count);
  n_wait = hypre_CTAlloc(int, ond_to_offd_count);
  send_queue = hypre_CTAlloc(hypre_Queue*, ond_to_offd_count);
  temp_local_ind_count = 0;
  for(i = 0; i < num_rows; i++) {
    if(temp_local_ind[i]) {
      V_i_S[temp_local_ind_count] = i;
      temp_local_ind_count++;
    }
  }
  hypre_TFree(temp_local_ind);


  // Determine the values of rho for the ond and offd nodes.
  ond_rho = hypre_CTAlloc(double, ond_to_offd_count);
  setRhoValuesOnd(ond_rho, ond_to_offd_count, V_i_S, row_starts);
  setRhoValuesOffd(offd_rho, offd_count, S_offd_map);

  // color-queue = {empty set}
  color_queue = newQueue();

  proc_send_count_list = hypre_CTAlloc(int, proc_count);
  proc_recv_count_list = hypre_CTAlloc(int, proc_count);
  // For each v in V_i^S do
  for(i = 0; i < ond_to_offd_count; i++) {
    // n-wait(v) = 0
    n_wait[i] = 0;

    // send-queue(v) = {empty set}
    send_queue[i] = newQueue();

    // For each edge (v,w) in E^S do
    for(j = S_offd_i[V_i_S[i]]; j < S_offd_i[V_i_S[i]+1]; j++) {
      if(offd_rho[S_offd_j[j]].rho > ond_rho[i]) {
	n_wait[i]++;
	proc_recv_count_list[hypre_BinarySearch(proc_list, offd_rho[S_offd_j[j]].proc, proc_count)]++;
      }
      else {
	data = hypre_CTAlloc(int, 2);
	data[0] = S_offd_map[S_offd_j[j]];
	data[1] = offd_rho[S_offd_j[j]].proc;
	proc_send_count_list[hypre_BinarySearch(proc_list, data[1], proc_count)]++;
	enqueueData(data, send_queue[i]);
      }
    }
    if(n_wait[i] == 0) {
      data = hypre_CTAlloc(int, 1);
      *data = i; // questionable
      enqueueData(data, color_queue);
    }
  }


  proc_send_list = hypre_CTAlloc(int*, proc_count);
  proc_send_list_ind = hypre_CTAlloc(int, proc_count);
  packed = hypre_CTAlloc(int, proc_count);
  proc_recv_list = hypre_CTAlloc(int*, proc_count);
  proc_recv_list_ind = hypre_CTAlloc(int, proc_count);
  for(i = 0; i < proc_count; i++) {
    if(proc_send_count_list[i] > 0)
      proc_send_list[i] = hypre_CTAlloc(int, 3*proc_send_count_list[i]);
    else
      proc_send_list[i] = NULL;
    if(proc_recv_count_list[i] > 0)
      proc_recv_list[i] = hypre_CTAlloc(int, 3*proc_recv_count_list[i]);
    else
      proc_recv_list[i] = NULL;
  }
  n_colored = color_queue->length;
  // Color any vertices in V_i^S not waiting for messages.
  colorQueue(S, color_array, offd_rho, color_queue, num_colors, send_queue, proc_list, proc_send_list, proc_send_list_ind, proc_count, packed, V_i_S);

  // Send the packed data in proc_send_list.
  for(i = 0; i < proc_count; i++) {
    if(packed[i]) {
      MPI_Isend(proc_send_list[i], 3*packed[i], MPI_INT,
		proc_list[i], 0, comm, &request);
    }
  }

  int * buffer, local_offd_ind, V_i_S_ind;
  buffer = hypre_CTAlloc(int, 3000);
  while(n_colored < ond_to_offd_count) {
    // Receive message.
    MPI_Recv(buffer, 3000, MPI_INT, MPI_ANY_SOURCE, 0, comm, &status);
    MPI_Get_count(&status, MPI_INT, &msg_size); // get the message size

    // Dig through the message.
    for(i = 0; i < msg_size; i += 3) {
      local_offd_ind = hypre_BinarySearch(global_ind, buffer[i+1], offd_count);
      V_i_S_ind = hypre_BinarySearch(V_i_S, buffer[i]-row_starts, ond_to_offd_count);
      offd_rho[local_ind[local_offd_ind]].color = buffer[i+2];
      if(V_i_S_ind > -1)
	n_wait[V_i_S_ind]--;
      if(V_i_S_ind > -1 && n_wait[V_i_S_ind] == 0) {
	data = hypre_CTAlloc(int, 1);
	*data = V_i_S_ind;
	enqueueData(data, color_queue);
      }
    }
    n_colored += color_queue->length;
    colorQueue(S, color_array, offd_rho, color_queue, num_colors, send_queue, proc_list, proc_send_list, proc_send_list_ind, proc_count, packed, V_i_S);
    // Send the packed data in proc_send_list.
    for(i = 0; i < proc_count; i++) {
      if(packed[i]) {
	MPI_Isend(&proc_send_list[i][proc_send_list_ind[i]-3*packed[i]],
		  3*packed[i], MPI_INT, proc_list[i], 0, comm, &request);
      }
    }
  }
  hypre_TFree(buffer);

/*   int buffer[1000]; */
/*   int wait, ip, size; */
/*   MPI_Status status; */
/*   if(my_id == 0) { */
/*     wait = 4; */
/*     ip = 1; */
/*     size = 12; */
/*   } */
/*   else { */
/*     wait = 2; */
/*     ip = 0; */
/*     size = 6; */
/*   } */
/*     size = MPI_Recv(buffer, 1000, MPI_INT, ip, 0, comm, &status); */
/*     MPI_Get_count(&status, MPI_INT, &size); */
/*     printf("%i %i\n", my_id, size); */

  seqColorGraphNewAgain(A, color_array, num_colors, V_i_S, ond_to_offd_count, level); //DELETE ME AND THE DECLARTION ABOVE THIS FUNCTION!!!!!!!!!!!!!!!!!!!!

  // Memory deallocation.
  for(i = 0; i < offd_count; i++) {
    curr_el = offd_rho[i].ond_neighbor_list->head;
    while(curr_el) {
      hypre_TFree(curr_el->data);
      curr_el = curr_el->next_elt;
    }
    destroyQueue(offd_rho[i].ond_neighbor_list);
  }
  hypre_TFree(offd_rho);
  hypre_TFree(global_ind);
  hypre_TFree(local_ind);
  hypre_TFree(V_i_S);
  hypre_TFree(n_wait);
  hypre_TFree(ond_rho);
  for(i = 0; i < ond_to_offd_count; i++) {
    curr_el = send_queue[i]->head;
    while(curr_el) {
      hypre_TFree(curr_el->data);
      curr_el = curr_el->next_elt;
    }
    destroyQueue(send_queue[i]);
  }
  hypre_TFree(send_queue);

  curr_el = color_queue->head;
  while(curr_el) {
    hypre_TFree(curr_el->data);
    curr_el = curr_el->next_elt;
  }
  destroyQueue(color_queue);
  hypre_TFree(proc_list);
  hypre_TFree(proc_send_count_list);
  hypre_TFree(proc_recv_count_list);
  hypre_TFree(proc_send_list);
  hypre_TFree(proc_send_list_ind);
  hypre_TFree(proc_recv_list);
  hypre_TFree(proc_recv_list_ind);
  hypre_TFree(packed);
}

void incrementNeighborCount(hypre_ParCSRMatrix * S, hypre_Queue * color_queue,
			    hypre_QueueElement * color_queue_array,
			    hypre_QueueElement ** degree_tail_array,
			    int * degree_null_beyond, int i, short * color_array)
{
  hypre_QueueElement * prev_elt;
  hypre_CSRMatrix * diag;
  int *neighbor_node_color_elt, *diag_i, *diag_j;
  int j, curr_node_degree_index;

  diag = hypre_ParCSRMatrixDiag(S);
  diag_i = hypre_CSRMatrixI(diag);
  diag_j = hypre_CSRMatrixJ(diag);

  neighbor_node_color_elt = color_queue_array[diag_j[i]].data;
  neighbor_node_color_elt[1]++;
  curr_node_degree_index = neighbor_node_color_elt[1]-1;

/* hypre_QueueElement *alk; */
/*  int here = 0; */
/* alk = color_queue->head;  */
/* while(alk) { */
/*   if(alk->data[0] == 5) { */
/*      printf("it's here!\n"); */
/*      here = 1; */
/*   } */
/*   alk = alk->next_elt; */
/*  } */
/*   if(!here) */
/*      printf("it's not here!\n"); */

  // The node adjacent in the queue will be needed later.
  prev_elt = color_queue_array[diag_j[i]].prev_elt;

  // Determine the destination location in the queue.
  if(degree_tail_array[curr_node_degree_index]) {
    // Then we are in luck and already know where to put this node.
    // Make sure the new location is not actually where the node is
    // now.
    if(degree_tail_array[curr_node_degree_index] != color_queue_array[diag_j[i]].prev_elt) {
      // Then a move is in order; else the node is in the right place.
      moveAfter(&color_queue_array[diag_j[i]],
		degree_tail_array[curr_node_degree_index], color_queue);
    }
  } 
  else {
    // The value of the pointer to the elements with the same number
    // of neighbors that have been colored as this node is NULL. That
    // means that this is the only node with this number of neighbors
    // that have been colored.
    //
    // The situation at this point can be one of a two.
    // 1) This node could be the node with the largest number of
    //    neighbors that have been colored.
    // 2) This node is not the node with the largest number of
    //    neighbors that have been colored.
    //
    // The difference between the two is visible by looking at
    // degree_null_beyond. If this node has more neighbors that have
    // been colored than the value of degree_null_beyond, then this
    // is the first case.
    if(curr_node_degree_index > *degree_null_beyond ||
       *degree_null_beyond == 0) {
      // Then this is the first case. Now this is the node with the
      // largest number of neighbors that have been colored.
      //
      // Additionally, this node is now at the head of the queue,
      // if it is not already there (i.e., it is not the last element).
      *degree_null_beyond = curr_node_degree_index;
      if(color_queue->head != &color_queue_array[diag_j[i]])
	moveToHead(&color_queue_array[diag_j[i]], color_queue);
    }
    else {
      // Then this is the second case. This is not the node with
      // the largest number of neighbors that have already been
      // colored, but it does have a unique number of neighbors that
      // have already been colored.
      //
      // It needs to be determined where this element is to be moved
      // in the queue. This is done by looking at
      // degree_tail_array[curr_node_degree_index+1,...,max_rownnz]
      // until a non-null element is found in degree_tail_array. The
      // element that is found will be the one to directly precede
      // this element in the queue.
      j = curr_node_degree_index+1;
      while(!degree_tail_array[j])
	j++;
      
      // Now we have the index of the element to precede this node.
      // Move the node there.
      moveAfter(&color_queue_array[diag_j[i]], degree_tail_array[j],
		color_queue);	      
    }
  }
  
  // Update the degree_tail_array for this element.
  degree_tail_array[curr_node_degree_index] = &color_queue_array[diag_j[i]];
  if(curr_node_degree_index > 0 &&
     degree_tail_array[curr_node_degree_index-1] == &color_queue_array[diag_j[i]]) {
    // Then the degree_tail_array points to this element already
    // from before. Remove that pointer.
    if(prev_elt && prev_elt->data[1] == curr_node_degree_index)
      degree_tail_array[curr_node_degree_index-1] = prev_elt;
    else
      degree_tail_array[curr_node_degree_index-1] = NULL;
  }
}

/** The function assigns a color to each node for this process.
 *
 * This works by using a greedy method to assign a color to a node.
 *
 * Basically it does a breadth first search and colors a node with the lowest possible color number such that no two adjacent nodes are the same color. The order in which the nodes are visited is determined using incidence degree ordering (IDO). The node with the largest number of adjacent nodes that have already been colored is colored next.
 *
 * NOTE:
 * Right now this is just a greedy graph coloring algorithm. If this produces good coarsening results the Jones-Plassmann parallel graph coloring should be implemented in its stead.
 *
 * @param S a hypre_ParCSRMatrix object containing the strength matrix of the linear system A.
 * @param color_array [OUT] an array of shorts containing color of each node.
 * @param num_colors a pointer to an integer storing the total number of colors in the graph.
 */
void seqColorGraph(hypre_ParCSRMatrix * S, short * color_array, int * num_colors, int level)
{
#define QUEUED        -1
#define UNCOLORED     0

  hypre_Queue        *color_queue;
  hypre_QueueElement *color_queue_array, *prev_elt;
  hypre_CSRMatrix    *diag;
  int                *node_color_elt, *neighbor_node_color_elt, *diag_i;
  int                *diag_j, *used_colors;
  int                i, j, curr_node, neighbor_color, curr_choice;
  int                num_variables, max_rownnz, curr_node_degree_index;
  int degree_null_beyond;
  hypre_QueueElement **degree_tail_array;

  color_queue = newQueue();
  *num_colors = 0;

  diag = hypre_ParCSRMatrixDiag(S);
  diag_i = hypre_CSRMatrixI(diag);
  diag_j = hypre_CSRMatrixJ(diag);

  num_variables = hypre_CSRMatrixNumRows(diag);

  // Determine the maximum degree of the graph.
  max_rownnz = 0;
  for(i = 0; i < num_variables; i++) {
    if(diag_i[i+1]-diag_i[i] > max_rownnz)
      max_rownnz = diag_i[i+1]-diag_i[i];
  }

  // The degree_tail_array contains pointers to specific elements in the
  // queue. For example, degree_tail_array[2] points to the last element
  // in the queue with three neighbors that have already been colored. The
  // pointer is to the last element so that when an element in the queue
  // needs to be moved up, it can be added to the end of the appropriate
  // "section" of elements.
  degree_tail_array = hypre_CTAlloc(hypre_QueueElement*, max_rownnz);
  // degree_null_beyond contains the largest index into degree_tail_array
  // that is not NULL. This way a node can quickly tell if it needs to go
  // to the head of the queue.
  degree_null_beyond = 0;

  if(num_variables > 0) {
    // Create hypre_QueueElements for each node.
    color_queue_array = hypre_CTAlloc(hypre_QueueElement, num_variables);

    // Set the data in each element and then enqueue the node.
    for(i = 0; i < num_variables; i++) {
      node_color_elt = hypre_CTAlloc(int, 2);
      node_color_elt[0] = i;
      node_color_elt[1] = 0; // zero neighbors that have been colored
      color_queue_array[i].data = node_color_elt;
    }
      enqueueElement(&color_queue_array[0], color_queue);
      color_array[0] = QUEUED;
  }

  while(color_queue->head) {
/*     // Temporary verification code. Make sure the queue is properly ordered. */
/*     hypre_QueueElement * cnode = color_queue->head; */
/*     int val = 1000000; */
/*     int prev_val; */
/*     while(cnode) { */
/*       prev_val = val; */
/*       val = cnode->data[1]; */
/*       if(val > prev_val) { */
/* 	printf("EEP!!!!!!!!!!!!!!!!! %i %i\n", prev_val, val); */
/* 	break; */
/*       } */
/*       //printf("%i(%i) ", val, cnode->data[0]); */
/*       cnode = cnode->next_elt; */
/*     } */
/*     //printf("\n\n"); */

    // while the queue still contains elements
    // color this node and enqueue all of its uncolored neighbors
    node_color_elt = dequeue(color_queue);
    curr_node = node_color_elt[0];

    // Check to see if this element was in the degree_tail_array. If it was,
    // then that entry in the degree_tail_array is to be set to NULL. Also,
    // search to find the next entry and update degree_null_beyond.
    if(node_color_elt[1] > 0 &&
       degree_tail_array[node_color_elt[1]-1] == &color_queue_array[curr_node]) {
      // Then this was the entry for its number of neighbors already colored
      // in degree_tail_array.
      degree_tail_array[node_color_elt[1]-1] = NULL;
      if(node_color_elt[1] > 0) {
	j = node_color_elt[1]-1;
	while(j > 0 && !degree_tail_array[j])
	  j--;
	
	// Now we have the index of next element in the degree_tail_array, or
	// the array is all NULL.
	degree_null_beyond = j;
      } else
	degree_null_beyond = 0;
    }

    used_colors = hypre_CTAlloc(int, diag_i[curr_node+1] - diag_i[curr_node]);
    // Get the neighbors of this node and also determine their colors.
    for(i = diag_i[curr_node]; i < diag_i[curr_node+1]; i++) {
      if(curr_node != diag_j[i]) {
	neighbor_color = color_array[diag_j[i]];
	
	if(neighbor_color == UNCOLORED || neighbor_color == QUEUED) {
	  if(neighbor_color == UNCOLORED) {
	    enqueueElement(&color_queue_array[diag_j[i]], color_queue);
	    color_array[diag_j[i]] = QUEUED;
	  }

	  // Since this neighbor is uncolored, increment the number
	  // of neighbors it has that are colored and move its position
	  // in the queue, if necessary.
	  neighbor_node_color_elt = color_queue_array[diag_j[i]].data;
	  neighbor_node_color_elt[1]++;
	  curr_node_degree_index = neighbor_node_color_elt[1]-1;

	  // The node adjacent in the queue will be needed later.
	  prev_elt = color_queue_array[diag_j[i]].prev_elt;

	  // Determine the destination location in the queue.
	  if(degree_tail_array[curr_node_degree_index]) {
	    // Then we are in luck and already know where to put this node.
	    // Make sure the new location is not actually where the node is
	    // now.
	    if(degree_tail_array[curr_node_degree_index] != color_queue_array[diag_j[i]].prev_elt) {
	      // Then a move is in order; else the node is in the right place.
	      moveAfter(&color_queue_array[diag_j[i]],
			degree_tail_array[curr_node_degree_index], color_queue);
	    }
	  } 
	  else {
	    // The value of the pointer to the elements with the same number
	    // of neighbors that have been colored as this node is NULL. That
	    // means that this is the only node with this number of neighbors
	    // that have been colored.
	    //
	    // The situation at this point can be one of a two.
	    // 1) This node could be the node with the largest number of
	    //    neighbors that have been colored.
	    // 2) This node is not the node with the largest number of
	    //    neighbors that have been colored.
	    //
	    // The difference between the two is visible by looking at
	    // degree_null_beyond. If this node has more neighbors that have
	    // been colored than the value of degree_null_beyond, then this
	    // is the first case.
	    if(curr_node_degree_index > degree_null_beyond ||
	       degree_null_beyond == 0) {
	      // Then this is the first case. Now this is the node with the
	      // largest number of neighbors that have been colored.
	      //
	      // Additionally, this node is now at the head of the queue,
	      // if it is not already there (i.e., it is not the last element).
	      degree_null_beyond = curr_node_degree_index;
	      if(color_queue->head != &color_queue_array[diag_j[i]])
		moveToHead(&color_queue_array[diag_j[i]], color_queue);
	    }
	    else {
	      // Then this is the second case. This is not the node with
	      // the largest number of neighbors that have already been
	      // colored, but it does have a unique number of neighbors that
	      // have already been colored.
	      //
	      // It needs to be determined where this element is to be moved
	      // in the queue. This is done by looking at
	      // degree_tail_array[curr_node_degree_index+1,...,max_rownnz]
	      // until a non-null element is found in degree_tail_array. The
	      // element that is found will be the one to directly precede
	      // this element in the queue.
	      j = curr_node_degree_index+1;
	      while(!degree_tail_array[j])
		j++;

	      // Now we have the index of the element to precede this node.
	      // Move the node there.
	      moveAfter(&color_queue_array[diag_j[i]], degree_tail_array[j],
			color_queue);	      
	    }
	  }

	  // Update the degree_tail_array for this element.
	  degree_tail_array[curr_node_degree_index] = &color_queue_array[diag_j[i]];
	  if(curr_node_degree_index > 0 &&
	     degree_tail_array[curr_node_degree_index-1] == &color_queue_array[diag_j[i]]) {
	    // Then the degree_tail_array points to this element already
	    // from before. Update that pointer.
	    if(prev_elt && prev_elt->data[1] == curr_node_degree_index)
	      degree_tail_array[curr_node_degree_index-1] = prev_elt;
	    else
	      degree_tail_array[curr_node_degree_index-1] = NULL;
	  }

	}
	else {
	  // Take note of this neighbor's color.
	  used_colors[i - diag_i[curr_node]] = neighbor_color;
	}
      }
    }

    // Color this node based on the information gathered.
    // Sort the used_colors array.
    qsort0(used_colors, 0, diag_i[curr_node+1] - diag_i[curr_node] - 1);

    // Now search the used_colors array to find the lowest number > 0 that
    // does not appear. Make that number the color of curr_node.
    curr_choice = 1;
    for(i = 0; i < diag_i[curr_node+1] - diag_i[curr_node]; i++) {
      if(used_colors[i] == curr_choice)
	// Then the current choice of color is in use. Pick the next one up.
	curr_choice++;
      else if(used_colors[i] > curr_choice) {
	// The the current choice of color is available. Exit the loop and
	// color curr_node this color.
	i = diag_i[curr_node+1] - diag_i[curr_node]; // to break loop
      }
    }
    color_array[curr_node] = curr_choice;
    if(curr_choice > *num_colors)
      *num_colors = curr_choice;
    
    hypre_TFree(used_colors);
  }
  WriteCoarseningColorInformation(S, color_array, level);

  hypre_TFree(degree_tail_array);
  for(i = 0; i < num_variables; i++)
    hypre_TFree(color_queue_array[i].data); // free all of the node_color_elt
  if(num_variables > 0)
    hypre_TFree(color_queue_array);
  destroyQueue(color_queue);
}

void seqColorGraphFromQueue(hypre_ParCSRMatrix * S, short * color_array, int * num_colors, int * V_i_S, int V_i_S_len, int level)
{
#define QUEUED        -1
#define UNCOLORED     0

  hypre_Queue        *color_queue;
  hypre_QueueElement *color_queue_array, *prev_elt;
  hypre_CSRMatrix    *diag;
  int                *node_color_elt, *neighbor_node_color_elt, *diag_i;
  int                *diag_j, *used_colors;
  int                i, j, curr_node, neighbor_color, curr_choice;
  int                num_variables, max_rownnz, curr_node_degree_index;
  int degree_null_beyond;
  hypre_QueueElement **degree_tail_array;

  color_queue = newQueue();
  //*num_colors = 0;

  diag = hypre_ParCSRMatrixDiag(S);
  diag_i = hypre_CSRMatrixI(diag);
  diag_j = hypre_CSRMatrixJ(diag);

  num_variables = hypre_CSRMatrixNumRows(diag);

  // Determine the maximum degree of the graph.
  max_rownnz = 0;
  for(i = 0; i < num_variables; i++) {
    if(diag_i[i+1]-diag_i[i] > max_rownnz)
      max_rownnz = diag_i[i+1]-diag_i[i];
  }

  // The degree_tail_array contains pointers to specific elements in the
  // queue. For example, degree_tail_array[2] points to the last element
  // in the queue with three neighbors that have already been colored. The
  // pointer is to the last element so that when an element in the queue
  // needs to be moved up, it can be added to the end of the appropriate
  // "section" of elements.
  degree_tail_array = hypre_CTAlloc(hypre_QueueElement*, max_rownnz);
  // degree_null_beyond contains the largest index into degree_tail_array
  // that is not NULL. This way a node can quickly tell if it needs to go
  // to the head of the queue.
  degree_null_beyond = 0;

  if(num_variables > 0) {
    // Create hypre_QueueElements for each node.
    color_queue_array = hypre_CTAlloc(hypre_QueueElement, num_variables);

    // Set the data in each element and then enqueue the node.
    for(i = 0; i < num_variables; i++) {
      node_color_elt = hypre_CTAlloc(int, 2);
      node_color_elt[0] = i;
      node_color_elt[1] = 0; // zero neighbors that have been colored
      color_queue_array[i].data = node_color_elt;
      if(color_array[i] <= 0) {
	enqueueElement(&color_queue_array[i], color_queue);
	color_array[i] = QUEUED;
      }
    }
      
    for(i = 0; i < V_i_S_len; i++) {
      // Update the number of neighbors that have been colored for all of
      // the nodes adjacent to the V_i_S nodes.
      for(j = diag_i[V_i_S[i]]; j < diag_i[V_i_S[i]+1]; j++) {
	if(color_array[diag_j[j]] == QUEUED) {
	  incrementNeighborCount(S, color_queue, color_queue_array,
				 degree_tail_array, &degree_null_beyond, j, color_array);
	}
      }
    }
  }

  while(color_queue->head) {
    // while the queue still contains elements
    // color this node and update all of its neighbors
    node_color_elt = dequeue(color_queue);
    curr_node = node_color_elt[0];

    // Check to see if this element was in the degree_tail_array. If it was,
    // then that entry in the degree_tail_array is to be set to NULL. Also,
    // search to find the next entry and update degree_null_beyond.
    if(node_color_elt[1] > 0 &&
       degree_tail_array[node_color_elt[1]-1] == &color_queue_array[curr_node]) {
      // Then this was the entry for its number of neighbors already colored
      // in degree_tail_array.
      degree_tail_array[node_color_elt[1]-1] = NULL;
      if(node_color_elt[1] > 0) {
	j = node_color_elt[1]-1;
	while(j > 0 && !degree_tail_array[j])
	  j--;
	
	// Now we have the index of next element in the degree_tail_array, or
	// the array is all NULL.
	degree_null_beyond = j;
      } else
	degree_null_beyond = 0;
    }

    used_colors = hypre_CTAlloc(int, diag_i[curr_node+1] - diag_i[curr_node]);
    // Get the neighbors of this node and also determine their colors.
    for(i = diag_i[curr_node]; i < diag_i[curr_node+1]; i++) {
      if(curr_node != diag_j[i]) {
	neighbor_color = color_array[diag_j[i]];
	
	if(neighbor_color == QUEUED) {
	  // Since this neighbor is uncolored, increment the number
	  // of neighbors it has that are colored and move its position
	  // in the queue, if necessary.
	  incrementNeighborCount(S, color_queue, color_queue_array,
				 degree_tail_array, &degree_null_beyond, i, color_array);
	}
	else {
	  // Take note of this neighbor's color.
	  used_colors[i - diag_i[curr_node]] = neighbor_color;
	}
      }
    }

    // Color this node based on the information gathered.
    // Sort the used_colors array.
    qsort0(used_colors, 0, diag_i[curr_node+1] - diag_i[curr_node] - 1);

    // Now search the used_colors array to find the lowest number > 0 that
    // does not appear. Make that number the color of curr_node.
    curr_choice = 1;
    for(i = 0; i < diag_i[curr_node+1] - diag_i[curr_node]; i++) {
      if(used_colors[i] == curr_choice)
	// Then the current choice of color is in use. Pick the next one up.
	curr_choice++;
      else if(used_colors[i] > curr_choice) {
	// The the current choice of color is available. Exit the loop and
	// color curr_node this color.
	i = diag_i[curr_node+1] - diag_i[curr_node]; // to break loop
      }
    }
    color_array[curr_node] = curr_choice;
    if(curr_choice > *num_colors)
      *num_colors = curr_choice;
    
    hypre_TFree(used_colors);
  }
  WriteCoarseningColorInformation(S, color_array, level);

  hypre_TFree(degree_tail_array);
  for(i = 0; i < num_variables; i++)
    hypre_TFree(color_queue_array[i].data); // free all of the node_color_elt
  if(num_variables > 0)
    hypre_TFree(color_queue_array);
  destroyQueue(color_queue);
}

void seqColorGraphNewAgain(hypre_ParCSRMatrix * S, short * color_array, int * num_colors, int * V_i_S, int V_i_S_len, int level)
{
#define QUEUED        -1
#define UNCOLORED     0

  hypre_Queue        *color_queue;
  hypre_QueueElement *color_queue_array, *prev_elt;
  hypre_CSRMatrix    *diag;
  int                *node_color_elt, *neighbor_node_color_elt, *diag_i;
  int                *diag_j, *used_colors;
  int                i, j, curr_node, neighbor_color, curr_choice;
  int                num_variables, max_rownnz, curr_node_degree_index;
  int degree_null_beyond;
  hypre_QueueElement **degree_tail_array;

  color_queue = newQueue();
  //*num_colors = 0;

  diag = hypre_ParCSRMatrixDiag(S);
  diag_i = hypre_CSRMatrixI(diag);
  diag_j = hypre_CSRMatrixJ(diag);

  num_variables = hypre_CSRMatrixNumRows(diag);

  // Determine the maximum degree of the graph.
  max_rownnz = 0;
  for(i = 0; i < num_variables; i++) {
    if(diag_i[i+1]-diag_i[i] > max_rownnz)
      max_rownnz = diag_i[i+1]-diag_i[i];
  }

  // The degree_tail_array contains pointers to specific elements in the
  // queue. For example, degree_tail_array[2] points to the last element
  // in the queue with three neighbors that have already been colored. The
  // pointer is to the last element so that when an element in the queue
  // needs to be moved up, it can be added to the end of the appropriate
  // "section" of elements.
  degree_tail_array = hypre_CTAlloc(hypre_QueueElement*, max_rownnz);
  // degree_null_beyond contains the largest index into degree_tail_array
  // that is not NULL. This way a node can quickly tell if it needs to go
  // to the head of the queue.
  degree_null_beyond = 0;

  if(num_variables > 0) {
    // Create hypre_QueueElements for each node.
    color_queue_array = hypre_CTAlloc(hypre_QueueElement, num_variables);

    // Set the data in each element and then enqueue the node.
    for(i = 0; i < num_variables; i++) {
      node_color_elt = hypre_CTAlloc(int, 2);
      node_color_elt[0] = i;
      node_color_elt[1] = 0; // zero neighbors that have been colored
      color_queue_array[i].data = node_color_elt;
      if(color_array[i] <= 0) {
	enqueueElement(&color_queue_array[i], color_queue);
	color_array[i] = QUEUED;
      }
    }
      
    for(i = 0; i < V_i_S_len; i++) {
      // Update the number of neighbors that have been colored for all of
      // the nodes adjacent to the V_i_S nodes.
      for(j = diag_i[V_i_S[i]]; j < diag_i[V_i_S[i]+1]; j++) {
	if(color_array[diag_j[j]] == QUEUED) {
	  incrementNeighborCount(S, color_queue, color_queue_array,
				 degree_tail_array, &degree_null_beyond, j, color_array);
	}
      }
    }
  }

  while(color_queue->head) {
    // while the queue still contains elements
    // color this node and update all of its neighbors
    node_color_elt = dequeue(color_queue);
    curr_node = node_color_elt[0];

    // Check to see if this element was in the degree_tail_array. If it was,
    // then that entry in the degree_tail_array is to be set to NULL. Also,
    // search to find the next entry and update degree_null_beyond.
    if(node_color_elt[1] > 0 &&
       degree_tail_array[node_color_elt[1]-1] == &color_queue_array[curr_node]) {
      // Then this was the entry for its number of neighbors already colored
      // in degree_tail_array.
      degree_tail_array[node_color_elt[1]-1] = NULL;
      if(node_color_elt[1] > 0) {
	j = node_color_elt[1]-1;
	while(j > 0 && !degree_tail_array[j])
	  j--;
	
	// Now we have the index of next element in the degree_tail_array, or
	// the array is all NULL.
	degree_null_beyond = j;
      } else
	degree_null_beyond = 0;
    }

    used_colors = hypre_CTAlloc(int, diag_i[curr_node+1] - diag_i[curr_node]);
    // Get the neighbors of this node and also determine their colors.
    for(i = diag_i[curr_node]; i < diag_i[curr_node+1]; i++) {
      if(curr_node != diag_j[i]) {
	neighbor_color = color_array[diag_j[i]];
	
	if(neighbor_color == QUEUED) {
	  // Since this neighbor is uncolored, increment the number
	  // of neighbors it has that are colored and move its position
	  // in the queue, if necessary.
	  incrementNeighborCount(S, color_queue, color_queue_array,
				 degree_tail_array, &degree_null_beyond, i, color_array);
	}
	else {
	  // Take note of this neighbor's color.
	  used_colors[i - diag_i[curr_node]] = neighbor_color;
	}
      }
    }

    // Color this node based on the information gathered.
    // Sort the used_colors array.
    qsort0(used_colors, 0, diag_i[curr_node+1] - diag_i[curr_node] - 1);

    // Now search the used_colors array to find the lowest number > 0 that
    // does not appear. Make that number the color of curr_node.
    curr_choice = 1;
    for(i = 0; i < diag_i[curr_node+1] - diag_i[curr_node]; i++) {
      if(used_colors[i] == curr_choice)
	// Then the current choice of color is in use. Pick the next one up.
	curr_choice++;
      else if(used_colors[i] > curr_choice) {
	// The the current choice of color is available. Exit the loop and
	// color curr_node this color.
	i = diag_i[curr_node+1] - diag_i[curr_node]; // to break loop
      }
    }
    color_array[curr_node] = curr_choice;
    if(curr_choice > *num_colors)
      *num_colors = curr_choice;
    
    hypre_TFree(used_colors);
  }
  WriteCoarseningColorInformation(S, color_array, level);

  hypre_TFree(degree_tail_array);
  for(i = 0; i < num_variables; i++)
    hypre_TFree(color_queue_array[i].data); // free all of the node_color_elt
  if(num_variables > 0)
    hypre_TFree(color_queue_array);
  destroyQueue(color_queue);
}

/* This is the same as the seqColorGraphNew with the exception that the uncommented version
   implements the color search (selecting the candidate color) more efficiently.

void seqColorGraphNew(hypre_ParCSRMatrix * S, short * color_array, int * num_colors, int level)
{
#define QUEUED        -1
#define UNCOLORED     0

  hypre_Queue        *color_queue;
  hypre_QueueElement *color_queue_array, *prev_elt;
  hypre_CSRMatrix    *diag;
  int                *node_color_elt, *neighbor_node_color_elt, *diag_i;
  int                *diag_j, *used_colors;
  int                i, j, curr_node, neighbor_color, curr_choice;
  int                num_variables, max_rownnz, curr_node_degree_index;
  int                degree_null_beyond, max_degree_node;
  hypre_QueueElement **degree_tail_array;

  color_queue = newQueue();
  *num_colors = 0;

  diag = hypre_ParCSRMatrixDiag(S);
  diag_i = hypre_CSRMatrixI(diag);
  diag_j = hypre_CSRMatrixJ(diag);

  num_variables = hypre_CSRMatrixNumRows(diag);

  // Determine the maximum degree of the graph and the first node that is of
  // maximum degree.
  max_rownnz = 0;
  for(i = 0; i < num_variables; i++) {
    if(diag_i[i+1]-diag_i[i] > max_rownnz) {
      max_rownnz = diag_i[i+1]-diag_i[i];
      max_degree_node = i;
    }
  }

  // The degree_tail_array contains pointers to specific elements in the
  // queue. For example, degree_tail_array[2] points to the last element
  // in the queue with three neighbors that have already been colored. The
  // pointer is to the last element so that when an element in the queue
  // needs to be moved up, it can be added to the end of the appropriate
  // "section" of elements.
  degree_tail_array = hypre_CTAlloc(hypre_QueueElement*, max_rownnz);
  // degree_null_beyond contains the largest index into degree_tail_array
  // that is not NULL. This way a node can quickly tell if it needs to go
  // to the head of the queue.
  degree_null_beyond = 0;

  if(num_variables > 0) {
    // Create hypre_QueueElements for each node.
    color_queue_array = hypre_CTAlloc(hypre_QueueElement, num_variables);

    // Set the data in each element and then enqueue the node.
    for(i = 0; i < num_variables; i++) {
      node_color_elt = hypre_CTAlloc(int, 2);
      node_color_elt[0] = i;
      node_color_elt[1] = 0; // zero neighbors that have been colored
      color_queue_array[i].data = node_color_elt;
      enqueueElement(&color_queue_array[i], color_queue);
      color_array[i] = QUEUED;
      if(i == max_degree_node)
	moveToHead(&color_queue_array[i], color_queue);
    }
  }

  while(color_queue->head) {
    // while the queue still contains elements
    node_color_elt = dequeue(color_queue);
    curr_node = node_color_elt[0];

    // Check to see if this element was in the degree_tail_array. If it was,
    // then that entry in the degree_tail_array is to be set to NULL. Also,
    // search to find the next entry and update degree_null_beyond.
    if(node_color_elt[1] > 0 &&
       degree_tail_array[node_color_elt[1]-1] == &color_queue_array[curr_node]) {
      // Then this was the entry for its number of neighbors already colored
      // in degree_tail_array.
      degree_tail_array[node_color_elt[1]-1] = NULL;
      if(node_color_elt[1] > 0) {
	j = node_color_elt[1]-1;
	while(j > 0 && !degree_tail_array[j])
	  j--;
	
	// Now we have the index of next element in the degree_tail_array, or
	// the array is all NULL.
	degree_null_beyond = j;
      } else
	degree_null_beyond = 0;
    }

    used_colors = hypre_CTAlloc(int, diag_i[curr_node+1] - diag_i[curr_node]);
    // Get the neighbors of this node and also determine their colors.
    for(i = diag_i[curr_node]; i < diag_i[curr_node+1]; i++) {
      if(curr_node != diag_j[i]) {
	neighbor_color = color_array[diag_j[i]];
	
	if(neighbor_color == QUEUED) {
	  // Since this neighbor is uncolored, increment the number
	  // of neighbors it has that are colored and move its position
	  // in the queue, if necessary.
	  neighbor_node_color_elt = color_queue_array[diag_j[i]].data;
	  neighbor_node_color_elt[1]++;
	  curr_node_degree_index = neighbor_node_color_elt[1]-1;

	  // The node adjacent in the queue will be needed later.
	  prev_elt = color_queue_array[diag_j[i]].prev_elt;

	  // Determine the destination location in the queue.
	  if(degree_tail_array[curr_node_degree_index]) {
	    // Then we are in luck and already know where to put this node.
	    // Make sure the new location is not actually where the node is
	    // now.
	    if(degree_tail_array[curr_node_degree_index] != color_queue_array[diag_j[i]].prev_elt) {
	      // Then a move is in order; else the node is in the right place.
	      moveAfter(&color_queue_array[diag_j[i]],
			degree_tail_array[curr_node_degree_index], color_queue);
	    }
	  } 
	  else {
	    // The value of the pointer to the elements with the same number
	    // of neighbors that have been colored as this node is NULL. That
	    // means that this is the only node with this number of neighbors
	    // that have been colored.
	    //
	    // The situation at this point can be one of two.
	    // 1) This node could be the node with the largest number of
	    //    neighbors that have been colored.
	    // 2) This node is not the node with the largest number of
	    //    neighbors that have been colored.
	    //
	    // The difference between the two is visible by looking at
	    // degree_null_beyond. If this node has more neighbors that have
	    // been colored than the value of degree_null_beyond, then this
	    // is the first case.
	    if(curr_node_degree_index > degree_null_beyond ||
	       degree_null_beyond == 0) {
	      // Then this is the first case. Now this is the node with the
	      // largest number of neighbors that have been colored.
	      //
	      // Additionally, this node is now at the head of the queue,
	      // if it is not already there (i.e., it is not the last element).
	      degree_null_beyond = curr_node_degree_index;
	      if(color_queue->head != &color_queue_array[diag_j[i]])
		moveToHead(&color_queue_array[diag_j[i]], color_queue);
	    }
	    else {
	      // Then this is the second case. This is not the node with
	      // the largest number of neighbors that have already been
	      // colored, but it does have a unique number of neighbors that
	      // have already been colored.
	      //
	      // It needs to be determined where this element is to be moved
	      // in the queue. This is done by looking at
	      // degree_tail_array[curr_node_degree_index+1,...,max_rownnz]
	      // until a non-null element is found in degree_tail_array. The
	      // element that is found will be the one to directly precede
	      // this element in the queue.
	      j = curr_node_degree_index+1;
	      while(!degree_tail_array[j])
		j++;

	      // Now we have the index of the element to precede this node.
	      // Move the node there.
	      moveAfter(&color_queue_array[diag_j[i]], degree_tail_array[j],
			color_queue);
	    }
	  }

	  // Update the degree_tail_array for this element.
	  degree_tail_array[curr_node_degree_index] = &color_queue_array[diag_j[i]];
	  if(curr_node_degree_index > 0 &&
	     degree_tail_array[curr_node_degree_index-1] == &color_queue_array[diag_j[i]]) {
	    // Then the degree_tail_array points to this element already
	    // from before. Remove that pointer.
	    if(prev_elt && prev_elt->data[1] == curr_node_degree_index)
	      degree_tail_array[curr_node_degree_index-1] = prev_elt;
	    else
	      degree_tail_array[curr_node_degree_index-1] = NULL;
	  }

	}
	else {
	  // Take note of this neighbor's color.
	  used_colors[i - diag_i[curr_node]] = neighbor_color;
	}
      }
    }

    // Color this node based on the information gathered.
    // Sort the used_colors array.
    qsort0(used_colors, 0, diag_i[curr_node+1] - diag_i[curr_node] - 1);

    // Now search the used_colors array to find the lowest number > 0 that
    // does not appear. Make that number the color of curr_node.
    curr_choice = 1;

    for(i = 0; i < diag_i[curr_node+1] - diag_i[curr_node]; i++) {
      if(used_colors[i] == curr_choice)
	// Then the current choice of color is in use. Pick the next one up.
	curr_choice++;
      else if(used_colors[i] > curr_choice) {
	// The the current choice of color is available. Exit the loop and
	// color curr_node this color.
	i = diag_i[curr_node+1] - diag_i[curr_node]; // to break loop
      }
    }
    color_array[curr_node] = curr_choice;
    if(curr_choice > *num_colors)
      *num_colors = curr_choice;
    
    hypre_TFree(used_colors);
  }
  WriteCoarseningColorInformation(S, color_array, level);

  hypre_TFree(degree_tail_array);
  for(i = 0; i < num_variables; i++)
    hypre_TFree(color_queue_array[i].data); // free all of the node_color_elt
  if(num_variables > 0)
    hypre_TFree(color_queue_array);
  destroyQueue(color_queue);
}*/

void seqColorGraphNew(hypre_ParCSRMatrix * S, short * color_array, int * num_colors, int level)
{
#define QUEUED        -1
#define UNCOLORED     0

  hypre_Queue        *color_queue;
  hypre_QueueElement *color_queue_array, *prev_elt;
  hypre_CSRMatrix    *diag;
  int                *node_color_elt, *neighbor_node_color_elt, *diag_i;
  int                *diag_j, *used_colors;
  int                i, j, curr_node, neighbor_color, curr_choice;
  int                num_variables, max_rownnz, curr_node_degree_index;
  int                degree_null_beyond, max_degree_node;
  hypre_QueueElement **degree_tail_array;

  color_queue = newQueue();
  *num_colors = 0;

  diag = hypre_ParCSRMatrixDiag(S);
  diag_i = hypre_CSRMatrixI(diag);
  diag_j = hypre_CSRMatrixJ(diag);

  num_variables = hypre_CSRMatrixNumRows(diag);

  // Determine the maximum degree of the graph and the first node that is of
  // maximum degree.
  max_rownnz = 0;
  for(i = 0; i < num_variables; i++) {
    if(diag_i[i+1]-diag_i[i] > max_rownnz) {
      max_rownnz = diag_i[i+1]-diag_i[i];
      max_degree_node = i;
    }
  }

  // The degree_tail_array contains pointers to specific elements in the
  // queue. For example, degree_tail_array[2] points to the last element
  // in the queue with three neighbors that have already been colored. The
  // pointer is to the last element so that when an element in the queue
  // needs to be moved up, it can be added to the end of the appropriate
  // "section" of elements.
  degree_tail_array = hypre_CTAlloc(hypre_QueueElement*, max_rownnz);
  // degree_null_beyond contains the largest index into degree_tail_array
  // that is not NULL. This way a node can quickly tell if it needs to go
  // to the head of the queue.
  degree_null_beyond = 0;

  if(num_variables > 0) {
    // Create hypre_QueueElements for each node.
    color_queue_array = hypre_CTAlloc(hypre_QueueElement, num_variables);

    // Set the data in each element and then enqueue the node.
    for(i = 0; i < num_variables; i++) {
      node_color_elt = hypre_CTAlloc(int, 2);
      node_color_elt[0] = i;
      node_color_elt[1] = 0; // zero neighbors that have been colored
      color_queue_array[i].data = node_color_elt;
      enqueueElement(&color_queue_array[i], color_queue);
      color_array[i] = QUEUED;
      if(i == max_degree_node)
	moveToHead(&color_queue_array[i], color_queue);
    }
  }

  while(color_queue->head) {
    // while the queue still contains elements
    node_color_elt = dequeue(color_queue);
    curr_node = node_color_elt[0];

    // Check to see if this element was in the degree_tail_array. If it was,
    // then that entry in the degree_tail_array is to be set to NULL. Also,
    // search to find the next entry and update degree_null_beyond.
    if(node_color_elt[1] > 0 &&
       degree_tail_array[node_color_elt[1]-1] == &color_queue_array[curr_node]) {
      // Then this was the entry for its number of neighbors already colored
      // in degree_tail_array.
      degree_tail_array[node_color_elt[1]-1] = NULL;
      if(node_color_elt[1] > 0) {
	j = node_color_elt[1]-1;
	while(j > 0 && !degree_tail_array[j])
	  j--;
	
	// Now we have the index of next element in the degree_tail_array, or
	// the array is all NULL.
	degree_null_beyond = j;
      } else
	degree_null_beyond = 0;
    }

    //used_colors = hypre_CTAlloc(int, diag_i[curr_node+1] - diag_i[curr_node]);
    used_colors = hypre_CTAlloc(int, *num_colors);
    // Get the neighbors of this node and also determine their colors.
    for(i = diag_i[curr_node]; i < diag_i[curr_node+1]; i++) {
      if(curr_node != diag_j[i]) {
	neighbor_color = color_array[diag_j[i]];
	
	if(neighbor_color == QUEUED) {
	  // Since this neighbor is uncolored, increment the number
	  // of neighbors it has that are colored and move its position
	  // in the queue, if necessary.
	  neighbor_node_color_elt = color_queue_array[diag_j[i]].data;
	  neighbor_node_color_elt[1]++;
	  curr_node_degree_index = neighbor_node_color_elt[1]-1;

	  // The node adjacent in the queue will be needed later.
	  prev_elt = color_queue_array[diag_j[i]].prev_elt;

	  // Determine the destination location in the queue.
	  if(degree_tail_array[curr_node_degree_index]) {
	    // Then we are in luck and already know where to put this node.
	    // Make sure the new location is not actually where the node is
	    // now.
	    if(degree_tail_array[curr_node_degree_index] != color_queue_array[diag_j[i]].prev_elt) {
	      // Then a move is in order; else the node is in the right place.
	      moveAfter(&color_queue_array[diag_j[i]],
			degree_tail_array[curr_node_degree_index], color_queue);
	    }
	  } 
	  else {
	    // The value of the pointer to the elements with the same number
	    // of neighbors that have been colored as this node is NULL. That
	    // means that this is the only node with this number of neighbors
	    // that have been colored.
	    //
	    // The situation at this point can be one of two.
	    // 1) This node could be the node with the largest number of
	    //    neighbors that have been colored.
	    // 2) This node is not the node with the largest number of
	    //    neighbors that have been colored.
	    //
	    // The difference between the two is visible by looking at
	    // degree_null_beyond. If this node has more neighbors that have
	    // been colored than the value of degree_null_beyond, then this
	    // is the first case.
	    if(curr_node_degree_index > degree_null_beyond ||
	       degree_null_beyond == 0) {
	      // Then this is the first case. Now this is the node with the
	      // largest number of neighbors that have been colored.
	      //
	      // Additionally, this node is now at the head of the queue,
	      // if it is not already there (i.e., it is not the last element).
	      degree_null_beyond = curr_node_degree_index;
	      if(color_queue->head != &color_queue_array[diag_j[i]])
		moveToHead(&color_queue_array[diag_j[i]], color_queue);
	    }
	    else {
	      // Then this is the second case. This is not the node with
	      // the largest number of neighbors that have already been
	      // colored, but it does have a unique number of neighbors that
	      // have already been colored.
	      //
	      // It needs to be determined where this element is to be moved
	      // in the queue. This is done by looking at
	      // degree_tail_array[curr_node_degree_index+1,...,max_rownnz]
	      // until a non-null element is found in degree_tail_array. The
	      // element that is found will be the one to directly precede
	      // this element in the queue.
	      j = curr_node_degree_index+1;
	      while(!degree_tail_array[j])
		j++;

	      // Now we have the index of the element to precede this node.
	      // Move the node there.
	      moveAfter(&color_queue_array[diag_j[i]], degree_tail_array[j],
			color_queue);
	    }
	  }

	  // Update the degree_tail_array for this element.
	  degree_tail_array[curr_node_degree_index] = &color_queue_array[diag_j[i]];
	  if(curr_node_degree_index > 0 &&
	     degree_tail_array[curr_node_degree_index-1] == &color_queue_array[diag_j[i]]) {
	    // Then the degree_tail_array points to this element already
	    // from before. Remove that pointer.
	    if(prev_elt && prev_elt->data[1] == curr_node_degree_index)
	      degree_tail_array[curr_node_degree_index-1] = prev_elt;
	    else
	      degree_tail_array[curr_node_degree_index-1] = NULL;
	  }

	}
	else {
	  // Take note of this neighbor's color.
	  //used_colors[i - diag_i[curr_node]] = neighbor_color;
	  used_colors[neighbor_color-1] = 1;
	}
      }
    }

    // Color this node based on the information gathered.
    // Search the used_colors array to find the lowest color number that is available.
    for(i = 0; i < *num_colors; i++) {
      if(!used_colors[i]) {
	// Then color i+1 is available. Store that information and exit loop.
	color_array[curr_node] = i+1;
	i = *num_colors;   // This breaks the loop.
      }
    }
    if(color_array[curr_node] == QUEUED) {
      // Then a new color is needed.
      color_array[curr_node] = *num_colors + 1;

      // Since the graph has more colors now, update num_colors.
      (*num_colors)++;
    }

    hypre_TFree(used_colors);
  }
  WriteCoarseningColorInformation(S, color_array, level);

  hypre_TFree(degree_tail_array);
  for(i = 0; i < num_variables; i++)
    hypre_TFree(color_queue_array[i].data); // free all of the node_color_elt
  if(num_variables > 0)
    hypre_TFree(color_queue_array);
  destroyQueue(color_queue);
}
void seqColorGraphD2(hypre_ParCSRMatrix * S, short * color_array, int * num_colors, int level)
     // Distance-two coloring algorithm.
{
#define QUEUED        -1
#define UNCOLORED     0

  hypre_Queue        *color_queue;
  hypre_QueueElement *color_queue_array, *prev_elt;
  hypre_CSRMatrix    *diag;
  int                *node_color_elt, *neighbor_node_color_elt, *diag_i;
  int                *diag_j, *used_colors;
  int                i, j, curr_node, neighbor_color, curr_choice;
  int                num_variables, max_rownnz, curr_node_degree_index;
  int                degree_null_beyond, max_degree_node;
  hypre_QueueElement **degree_tail_array;

  color_queue = newQueue();
  *num_colors = 0;

  diag = hypre_ParCSRMatrixDiag(S);
  diag_i = hypre_CSRMatrixI(diag);
  diag_j = hypre_CSRMatrixJ(diag);

  num_variables = hypre_CSRMatrixNumRows(diag);

  // Determine the maximum degree of the graph and the first node that is of
  // maximum degree.
  max_rownnz = 0;
  for(i = 0; i < num_variables; i++) {
    if(diag_i[i+1]-diag_i[i] > max_rownnz) {
      max_rownnz = diag_i[i+1]-diag_i[i];
      max_degree_node = i;
    }
  }

  // The degree_tail_array contains pointers to specific elements in the
  // queue. For example, degree_tail_array[2] points to the last element
  // in the queue with three neighbors that have already been colored. The
  // pointer is to the last element so that when an element in the queue
  // needs to be moved up, it can be added to the end of the appropriate
  // "section" of elements.
  degree_tail_array = hypre_CTAlloc(hypre_QueueElement*, max_rownnz);
  // degree_null_beyond contains the largest index into degree_tail_array
  // that is not NULL. This way a node can quickly tell if it needs to go
  // to the head of the queue.
  degree_null_beyond = 0;

  if(num_variables > 0) {
    // Create hypre_QueueElements for each node.
    color_queue_array = hypre_CTAlloc(hypre_QueueElement, num_variables);

    // Set the data in each element and then enqueue the node.
    for(i = 0; i < num_variables; i++) {
      node_color_elt = hypre_CTAlloc(int, 2);
      node_color_elt[0] = i;
      node_color_elt[1] = 0; // zero neighbors that have been colored
      color_queue_array[i].data = node_color_elt;
      enqueueElement(&color_queue_array[i], color_queue);
      color_array[i] = QUEUED;
      if(i == max_degree_node)
	moveToHead(&color_queue_array[i], color_queue);
    }
  }

  while(color_queue->head) {
    // while the queue still contains elements
    node_color_elt = dequeue(color_queue);
    curr_node = node_color_elt[0];

    // Check to see if this element was in the degree_tail_array. If it was,
    // then that entry in the degree_tail_array is to be set to NULL. Also,
    // search to find the next entry and update degree_null_beyond.
    if(node_color_elt[1] > 0 &&
       degree_tail_array[node_color_elt[1]-1] == &color_queue_array[curr_node]) {
      // Then this was the entry for its number of neighbors already colored
      // in degree_tail_array.
      degree_tail_array[node_color_elt[1]-1] = NULL;
      if(node_color_elt[1] > 0) {
	j = node_color_elt[1]-1;
	while(j > 0 && !degree_tail_array[j])
	  j--;
	
	// Now we have the index of next element in the degree_tail_array, or
	// the array is all NULL.
	degree_null_beyond = j;
      } else
	degree_null_beyond = 0;
    }

    //used_colors = hypre_CTAlloc(int, diag_i[curr_node+1] - diag_i[curr_node]);
    used_colors = hypre_CTAlloc(int, *num_colors);
    // Get the neighbors of this node and also determine their colors.
    for(i = diag_i[curr_node]; i < diag_i[curr_node+1]; i++) {
      if(curr_node != diag_j[i]) {
	neighbor_color = color_array[diag_j[i]];

	// Determine the color of each of the neighbor node's neighbors and mark those
	// as used colors. This is the step the enforces the distance-two coloring.
	int neighbor_id, neighbors_neighbor_color, k;
	neighbor_id = diag_j[i];
	for(k = diag_i[neighbor_id]; k < diag_i[neighbor_id+1]; k++) {
	  neighbors_neighbor_color = color_array[diag_j[k]];
	  if(neighbors_neighbor_color > 0)
	    used_colors[neighbors_neighbor_color-1] = 1;
	}
	
	if(neighbor_color == QUEUED) {
	  // Since this neighbor is uncolored, increment the number
	  // of neighbors it has that are colored and move its position
	  // in the queue, if necessary.
	  neighbor_node_color_elt = color_queue_array[diag_j[i]].data;
	  neighbor_node_color_elt[1]++;
	  curr_node_degree_index = neighbor_node_color_elt[1]-1;

	  // The node adjacent in the queue will be needed later.
	  prev_elt = color_queue_array[diag_j[i]].prev_elt;

	  // Determine the destination location in the queue.
	  if(degree_tail_array[curr_node_degree_index]) {
	    // Then we are in luck and already know where to put this node.
	    // Make sure the new location is not actually where the node is
	    // now.
	    if(degree_tail_array[curr_node_degree_index] != color_queue_array[diag_j[i]].prev_elt) {
	      // Then a move is in order; else the node is in the right place.
	      moveAfter(&color_queue_array[diag_j[i]],
			degree_tail_array[curr_node_degree_index], color_queue);
	    }
	  } 
	  else {
	    // The value of the pointer to the elements with the same number
	    // of neighbors that have been colored as this node is NULL. That
	    // means that this is the only node with this number of neighbors
	    // that have been colored.
	    //
	    // The situation at this point can be one of two.
	    // 1) This node could be the node with the largest number of
	    //    neighbors that have been colored.
	    // 2) This node is not the node with the largest number of
	    //    neighbors that have been colored.
	    //
	    // The difference between the two is visible by looking at
	    // degree_null_beyond. If this node has more neighbors that have
	    // been colored than the value of degree_null_beyond, then this
	    // is the first case.
	    if(curr_node_degree_index > degree_null_beyond ||
	       degree_null_beyond == 0) {
	      // Then this is the first case. Now this is the node with the
	      // largest number of neighbors that have been colored.
	      //
	      // Additionally, this node is now at the head of the queue,
	      // if it is not already there (i.e., it is not the last element).
	      degree_null_beyond = curr_node_degree_index;
	      if(color_queue->head != &color_queue_array[diag_j[i]])
		moveToHead(&color_queue_array[diag_j[i]], color_queue);
	    }
	    else {
	      // Then this is the second case. This is not the node with
	      // the largest number of neighbors that have already been
	      // colored, but it does have a unique number of neighbors that
	      // have already been colored.
	      //
	      // It needs to be determined where this element is to be moved
	      // in the queue. This is done by looking at
	      // degree_tail_array[curr_node_degree_index+1,...,max_rownnz]
	      // until a non-null element is found in degree_tail_array. The
	      // element that is found will be the one to directly precede
	      // this element in the queue.
	      j = curr_node_degree_index+1;
	      while(!degree_tail_array[j])
		j++;

	      // Now we have the index of the element to precede this node.
	      // Move the node there.
	      moveAfter(&color_queue_array[diag_j[i]], degree_tail_array[j],
			color_queue);
	    }
	  }

	  // Update the degree_tail_array for this element.
	  degree_tail_array[curr_node_degree_index] = &color_queue_array[diag_j[i]];
	  if(curr_node_degree_index > 0 &&
	     degree_tail_array[curr_node_degree_index-1] == &color_queue_array[diag_j[i]]) {
	    // Then the degree_tail_array points to this element already
	    // from before. Remove that pointer.
	    if(prev_elt && prev_elt->data[1] == curr_node_degree_index)
	      degree_tail_array[curr_node_degree_index-1] = prev_elt;
	    else
	      degree_tail_array[curr_node_degree_index-1] = NULL;
	  }

	}
	else {
	  // Take note of this neighbor's color.
	  //used_colors[i - diag_i[curr_node]] = neighbor_color;
	  used_colors[neighbor_color-1] = 1;
	}
      }
    }

    // Color this node based on the information gathered.
    // Search the used_colors array to find the lowest color number that is available.
    for(i = 0; i < *num_colors; i++) {
      if(!used_colors[i]) {
	// Then color i+1 is available. Store that information and exit loop.
	color_array[curr_node] = i+1;
	i = *num_colors;   // This breaks the loop.
      }
    }
    if(color_array[curr_node] == QUEUED) {
      // Then a new color is needed.
      color_array[curr_node] = *num_colors + 1;

      // Since the graph has more colors now, update num_colors.
      (*num_colors)++;
    }

    hypre_TFree(used_colors);
  }
  WriteCoarseningColorInformation(S, color_array, level);

  hypre_TFree(degree_tail_array);
  for(i = 0; i < num_variables; i++)
    hypre_TFree(color_queue_array[i].data); // free all of the node_color_elt
  if(num_variables > 0)
    hypre_TFree(color_queue_array);
  destroyQueue(color_queue);
}

void seqColorGraphOrig(hypre_ParCSRMatrix * S, short * color_array, int * num_colors, int level)
{
#define QUEUED        -1
#define UNCOLORED     0

  hypre_Queue        *color_queue;
  hypre_QueueElement *color_queue_array, *prev_elt;
  hypre_CSRMatrix    *diag;
  int                *node_color_elt, *diag_i, *diag_j, *used_colors;
  int                i, curr_node, neighbor_color, curr_choice, num_variables;
  int max_rownnz;

  color_queue = newQueue();
  *num_colors = 0;

  diag = hypre_ParCSRMatrixDiag(S);
  diag_i = hypre_CSRMatrixI(diag);
  diag_j = hypre_CSRMatrixJ(diag);

  num_variables = hypre_CSRMatrixNumRows(diag);

  max_rownnz = 0;
  for(i = 0; i < num_variables; i++) {
    if(diag_i[i+1]-diag_i[i] > max_rownnz)
      max_rownnz = diag_i[i+1]-diag_i[i];
  }

  if(num_variables > 0) {

    // Create hypre_QueueElements for each node.
    color_queue_array = hypre_CTAlloc(hypre_QueueElement, num_variables);

    // Set the data in each element and then enqueue the node.
    for(i = 0; i < num_variables; i++) {
      node_color_elt = hypre_CTAlloc(int, 2);
      node_color_elt[0] = i;
      node_color_elt[1] = 0; // zero neighbors that have been colored
      color_queue_array[i].data = node_color_elt;
    }
    enqueueElement(&color_queue_array[0], color_queue);
    color_array[0] = QUEUED;
  }

  while(color_queue->head) {
    // while the queue still contains elements
    // color this node and enqueue all of its uncolored neighbors
    node_color_elt = dequeue(color_queue);

    curr_node = node_color_elt[0];
    used_colors = hypre_CTAlloc(int, diag_i[curr_node+1] - diag_i[curr_node]);
    // Get the neighbors of this node and also determine their colors.
    for(i = diag_i[curr_node]; i < diag_i[curr_node+1]; i++) {
      if(curr_node != diag_j[i]) {
	neighbor_color = color_array[diag_j[i]];
	
	if(neighbor_color == UNCOLORED || neighbor_color == QUEUED) {
	  if(neighbor_color == UNCOLORED) {
	    enqueueElement(&color_queue_array[diag_j[i]], color_queue);
	    color_array[diag_j[i]] = QUEUED;
	  }

	  // Since this neighbor is uncolored, increment the number
	  // of neighbors it has that are colored and move its position
	  // in the queue, if necessary.
	  color_queue_array[diag_j[i]].data[1]++;
	  prev_elt = color_queue_array[diag_j[i]].prev_elt;

	  while(prev_elt && prev_elt->data[1] < color_queue_array[diag_j[i]].data[1]) {
	    prev_elt = prev_elt->prev_elt;
	  }
	  if(prev_elt != color_queue_array[diag_j[i]].prev_elt)
	    moveAfter(&color_queue_array[diag_j[i]], prev_elt, color_queue);
	  // else there is no moving to be done
	}
	else {
	  // Take note of this neighbor's color.
	  used_colors[i - diag_i[curr_node]] = neighbor_color;
	}
      }
    }

    // Color this node based on the information gathered.
    // Sort the used_colors array.
    qsort0(used_colors, 0, diag_i[curr_node+1] - diag_i[curr_node] - 1);

    // Now search the used_colors array to find the lowest number > 0 that
    // does not appear. Make that number the color of curr_node.
    curr_choice = 1;
    for(i = 0; i < diag_i[curr_node+1] - diag_i[curr_node]; i++) {
      if(used_colors[i] == curr_choice)
	// Then the current choice of color is in use. Pick the next one up.
	curr_choice++;
      else if(used_colors[i] > curr_choice) {
	// The the current choice of color is available. Exit the loop and
	// color curr_node this color.
	i = diag_i[curr_node+1] - diag_i[curr_node]; // to break loop
      }
    }
    color_array[curr_node] = curr_choice;
    if(curr_choice > *num_colors)
      *num_colors = curr_choice;
    
    hypre_TFree(used_colors);
  }
  WriteCoarseningColorInformation(S, color_array, level);

  destroyQueue(color_queue);
  hypre_TFree(color_queue_array);
  hypre_TFree(node_color_elt);
}

int
hypre_BoomerAMGCoarsenCLJP_c( hypre_ParCSRMatrix    *S,
                        hypre_ParCSRMatrix    *A,
                        int                    CF_init,
                        int                    debug_flag,
                        int                  **CF_marker_ptr,
			int                    global,
			int                    level,
			double                *measure_array)
{
   MPI_Comm 	       comm            = hypre_ParCSRMatrixComm(S);
   hypre_ParCSRCommPkg      *comm_pkg        = hypre_ParCSRMatrixCommPkg(A);
   hypre_ParCSRCommHandle   *comm_handle;

   hypre_CSRMatrix    *S_diag          = hypre_ParCSRMatrixDiag(S);
   int                *S_diag_i        = hypre_CSRMatrixI(S_diag);
   int                *S_diag_j        = hypre_CSRMatrixJ(S_diag);

   hypre_CSRMatrix    *S_offd          = hypre_ParCSRMatrixOffd(S);
   int                *S_offd_i        = hypre_CSRMatrixI(S_offd);
   int                *S_offd_j;

   int 		      *col_map_offd    = hypre_ParCSRMatrixColMapOffd(S);
   int                 num_variables   = hypre_CSRMatrixNumRows(S_diag);
   int		       col_1 = hypre_ParCSRMatrixFirstColDiag(S);
   int		       col_n = col_1 + hypre_CSRMatrixNumCols(S_diag);
   int 		       num_cols_offd = 0;
                  
   hypre_CSRMatrix    *S_ext;
   int                *S_ext_i;
   int                *S_ext_j;

   int		       num_sends = 0;
   int  	      *int_buf_data;
   double	      *buf_data;

   int                *CF_marker;
   int                *CF_marker_offd;

   short              *color_array = NULL;
   int                num_colors;
                      
   //double             *measure_array;
   int                *graph_array;
   int                *graph_array_offd;
   int                 graph_size;
   int                 graph_offd_size;
   int                 global_graph_size;
                      
   int                 i, j, k, kc, jS, kS, ig;
   int		       index, start, my_id, num_procs, jrow, cnt;
                      
   int                 ierr = 0;
   int                 break_var = 1;

   double	    wall_time;
   int   iter = 0;

#if 0 /* debugging */
   char  filename[256];
   FILE *fp;
   int   iter = 0;
#endif

   if(!measure_array) {
     // Then the coloring needs to be done. The only time this is not needed is if
     // the calling function already has the measure_array computed. The CR function
     // does this because it calls CLJP_c several times for each level. By computing
     // the measure_array ahead of time, extra computation can be saved.
     color_array = hypre_CTAlloc(short, num_variables);

     if(global)
       //parColorGraph(A, S, color_array, &num_colors, level);
       parColorGraphNew(A, S, color_array, &num_colors, level);
     else
       seqColorGraphNew(S, color_array, &num_colors, level);
   }
   
   /*--------------------------------------------------------------
    * Compute a  ParCSR strength matrix, S.
    *
    * For now, the "strength" of dependence/influence is defined in
    * the following way: i depends on j if
    *     aij > hypre_max (k != i) aik,    aii < 0
    * or
    *     aij < hypre_min (k != i) aik,    aii >= 0
    * Then S_ij = 1, else S_ij = 0.
    *
    * NOTE: the entries are negative initially, corresponding
    * to "unaccounted-for" dependence.
    *----------------------------------------------------------------*/

   S_ext = NULL;
   if (debug_flag == 3) wall_time = time_getWallclockSeconds();
   MPI_Comm_size(comm,&num_procs);
   MPI_Comm_rank(comm,&my_id);
   if (!comm_pkg)
   {
        hypre_MatvecCommPkgCreate(A);
        comm_pkg = hypre_ParCSRMatrixCommPkg(A);
   }

   num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);

   int_buf_data = hypre_CTAlloc(int, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
   buf_data = hypre_CTAlloc(double, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
 
   num_cols_offd = hypre_CSRMatrixNumCols(S_offd);

   S_diag_j = hypre_CSRMatrixJ(S_diag);

   if (num_cols_offd)
   {
      S_offd_j = hypre_CSRMatrixJ(S_offd);
   }
   /*----------------------------------------------------------
    * Compute the measures
    *
    * The measures are currently given by the column sums of S.
    * Hence, measure_array[i] is the number of influences
    * of variable i.
    *
    * The measures are augmented by a random number
    * between 0 and 1.
    *----------------------------------------------------------*/

   if(!measure_array) {
     // Then the measure array needs to be computed. The CR function
     // computes the measure_array ahead of time to save extra
     // computation.
   measure_array = hypre_CTAlloc(double, num_variables+num_cols_offd);

   for (i=0; i < S_offd_i[num_variables]; i++)
   {
      measure_array[num_variables + S_offd_j[i]] += 1.0;
   }
   if (num_procs > 1)
   comm_handle = hypre_ParCSRCommHandleCreate(2, comm_pkg,
                        &measure_array[num_variables], buf_data);

   for (i=0; i < S_diag_i[num_variables]; i++)
   {
      measure_array[S_diag_j[i]] += 1.0;
   }

   if (num_procs > 1)
   hypre_ParCSRCommHandleDestroy(comm_handle);
      
   index = 0;
   for (i=0; i < num_sends; i++)
   {
      start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
      for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
            measure_array[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)]
                        += buf_data[index++];
   }

   for (i=num_variables; i < num_variables+num_cols_offd; i++)
   /* This loop zeros out the measures for the off-process nodes since
      this process is not responsible for . */
   {
      measure_array[i] = 0;
   }

   /* this augments the measures */
   //hypre_BoomerAMGIndepSetInit(S, measure_array);
   hypre_BoomerAMGIndepSetInitb(S, measure_array, color_array, num_colors);
   }

   /*---------------------------------------------------
    * Initialize the graph array
    * graph_array contains interior points in elements 0 ... num_variables-1
    * followed by boundary values
    *---------------------------------------------------*/

   graph_array = hypre_CTAlloc(int, num_variables);
   if (num_cols_offd)
      graph_array_offd = hypre_CTAlloc(int, num_cols_offd);
   else
      graph_array_offd = NULL;

   /* initialize measure array and graph array */

   for (ig = 0; ig < num_cols_offd; ig++)
      graph_array_offd[ig] = ig;

   /*---------------------------------------------------
    * Initialize the C/F marker array
    * C/F marker array contains interior points in elements 0 ...
    * num_variables-1  followed by boundary values
    *---------------------------------------------------*/

   graph_offd_size = num_cols_offd;

   if (CF_init)
   {
      CF_marker = *CF_marker_ptr;
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
         if ( (S_offd_i[i+1]-S_offd_i[i]) > 0
                 || CF_marker[i] == -1)
         {
	   if(CF_marker[i] != SF_PT)
            CF_marker[i] = 0;
         }
         if ( CF_marker[i] == Z_PT)
         {
            if (measure_array[i] >= 1.0 ||
                (S_diag_i[i+1]-S_diag_i[i]) > 0)
            {
               CF_marker[i] = 0;
               graph_array[cnt++] = i;
            }
            else
            {
               graph_size--;
               CF_marker[i] = F_PT;
            }
         }
         else if (CF_marker[i] == SF_PT)
	    measure_array[i] = 0;
         else
            graph_array[cnt++] = i;
      }
   }
   else
   {
      CF_marker = hypre_CTAlloc(int, num_variables);
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
	 CF_marker[i] = 0;
	 if ( (S_diag_i[i+1]-S_diag_i[i]) == 0
		&& (S_offd_i[i+1]-S_offd_i[i]) == 0)
	 {
	    CF_marker[i] = SF_PT;
	    measure_array[i] = 0;
	 }
	 else
            graph_array[cnt++] = i;
      }
   }
   graph_size = cnt;
   if (num_cols_offd)
      CF_marker_offd = hypre_CTAlloc(int, num_cols_offd);
   else
      CF_marker_offd = NULL;
   for (i=0; i < num_cols_offd; i++)
	CF_marker_offd[i] = 0;
  
   /*---------------------------------------------------
    * Loop until all points are either fine or coarse.
    *---------------------------------------------------*/

   if (num_procs > 1)
   {
      S_ext      = hypre_ParCSRMatrixExtractBExt(S,A,0);
      S_ext_i    = hypre_CSRMatrixI(S_ext);
      S_ext_j    = hypre_CSRMatrixJ(S_ext);
   }

   /*  compress S_ext  and convert column numbers*/

   index = 0;
   for (i=0; i < num_cols_offd; i++)
   {
      for (j=S_ext_i[i]; j < S_ext_i[i+1]; j++)
      {
	 k = S_ext_j[j];
	 if (k >= col_1 && k < col_n)
	 {
	    S_ext_j[index++] = k - col_1;
	 }
	 else
	 {
	    kc = hypre_BinarySearch(col_map_offd,k,num_cols_offd);
	    if (kc > -1) S_ext_j[index++] = -kc-1;
	 }
      }
      S_ext_i[i] = index;
   }
   for (i = num_cols_offd; i > 0; i--)
      S_ext_i[i] = S_ext_i[i-1];
   if (num_procs > 1) S_ext_i[0] = 0;

   if (debug_flag == 3)
   {
      wall_time = time_getWallclockSeconds() - wall_time;
      printf("Proc = %d    Initialize CLJP phase = %f\n",
                     my_id, wall_time);
   }

   while (1)
   {
      /*------------------------------------------------
       * Exchange boundary data, i.i. get measures and S_ext_data
       *------------------------------------------------*/

      if (num_procs > 1)
   	 comm_handle = hypre_ParCSRCommHandleCreate(2, comm_pkg,
                        &measure_array[num_variables], buf_data);

      if (num_procs > 1)
   	 hypre_ParCSRCommHandleDestroy(comm_handle);
      
      index = 0;
      for (i=0; i < num_sends; i++)
      {
         start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
         for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
            measure_array[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)]
                        += buf_data[index++];
      }

      /*------------------------------------------------
       * Set F-pts and update subgraph
       *------------------------------------------------*/
 
      if (iter || !CF_init)
      {
         for (ig = 0; ig < graph_size; ig++)
         {
            i = graph_array[ig];

            if ( (CF_marker[i] != C_PT) && (measure_array[i] < 1) )
            {
               /* set to be an F-pt */
               CF_marker[i] = F_PT;
 
	       /* make sure all dependencies have been accounted for */
               for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     CF_marker[i] = 0;
                  }
               }
               for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     CF_marker[i] = 0;
                  }
               }
            }
            if (CF_marker[i])
            {
               measure_array[i] = 0;
 
               /* take point out of the subgraph */
               graph_size--;
               graph_array[ig] = graph_array[graph_size];
               graph_array[graph_size] = i;
               ig--;
            }
         }
      }
 
      /*------------------------------------------------
       * Exchange boundary data, i.i. get measures
       *------------------------------------------------*/

      if (debug_flag == 3) wall_time = time_getWallclockSeconds();

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
        {
            jrow = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
            buf_data[index++] = measure_array[jrow];
         }
      }

      if (num_procs > 1)
      {
         comm_handle = hypre_ParCSRCommHandleCreate(1, comm_pkg, buf_data,
        	&measure_array[num_variables]);
 
         hypre_ParCSRCommHandleDestroy(comm_handle);
 
      }
      /*------------------------------------------------
       * Debugging:
       *
       * Uncomment the sections of code labeled
       * "debugging" to generate several files that
       * can be visualized using the `coarsen.m'
       * matlab routine.
       *------------------------------------------------*/

#if 0 /* debugging */
      /* print out measures */
      char filename[50];
      FILE * fp;
      sprintf(filename, "coarsen.out.measures.%04d", iter);
      fp = fopen(filename, "w");
      for (i = 0; i < num_variables; i++)
      {
         fprintf(fp, "%f\n", measure_array[i]);
      }
      fclose(fp);

      /* print out strength matrix */
      sprintf(filename, "coarsen.out.strength.%04d", iter);
      hypre_CSRMatrixPrint(S, filename);

      /* print out C/F marker */
      sprintf(filename, "coarsen.out.CF.%04d", iter);
      fp = fopen(filename, "w");
      for (i = 0; i < num_variables; i++)
      {
         fprintf(fp, "%d\n", CF_marker[i]);
      }
      fclose(fp);

      //iter++;
#endif

      /*------------------------------------------------
       * Test for convergence
       *------------------------------------------------*/

      MPI_Allreduce(&graph_size,&global_graph_size,1,MPI_INT,MPI_SUM,comm);

      if (global_graph_size == 0)
         break;

      /*------------------------------------------------
       * Pick an independent set of points with
       * maximal measure.
       *------------------------------------------------*/
      if (iter || !CF_init)
         hypre_BoomerAMGIndepSet(S, measure_array, graph_array,
				graph_size,
				graph_array_offd, graph_offd_size,
				CF_marker, CF_marker_offd);

      iter++;
      /*------------------------------------------------
       * Exchange boundary data for CF_marker
       *------------------------------------------------*/

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
                int_buf_data[index++]
                 = CF_marker[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)];
      }
 
      if (num_procs > 1)
      {
      comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data,
        CF_marker_offd);
 
      hypre_ParCSRCommHandleDestroy(comm_handle);
      }
 
      for (ig = 0; ig < graph_offd_size; ig++)
      {
         i = graph_array_offd[ig];

         if (CF_marker_offd[i] < 0)
         {
            /* take point out of the subgraph */
            graph_offd_size--;
            graph_array_offd[ig] = graph_array_offd[graph_offd_size];
            graph_array_offd[graph_offd_size] = i;
            ig--;
         }
      }
      if (debug_flag == 3)
      {
         wall_time = time_getWallclockSeconds() - wall_time;
         printf("Proc = %d  iter %d  comm. and subgraph update = %f\n",
                     my_id, iter, wall_time);
      }
      /*------------------------------------------------
       * Set C_pts and apply heuristics.
       *------------------------------------------------*/

      for (i=num_variables; i < num_variables+num_cols_offd; i++)
      {
         measure_array[i] = 0;
      }

      if (debug_flag == 3) wall_time = time_getWallclockSeconds();
      for (ig = 0; ig < graph_size; ig++)
      {
         i = graph_array[ig];

         /*---------------------------------------------
          * Heuristic: C-pts don't interpolate from
          * neighbors that influence them.
          *---------------------------------------------*/

         if (CF_marker[i] > 0)
         {
            /* set to be a C-pt */
            CF_marker[i] = C_PT;

            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               j = S_diag_j[jS];
               if (j > -1)
               {
               
                  /* "remove" edge from S */
                  S_diag_j[jS] = -S_diag_j[jS]-1;
             
                  /* decrement measures of unmarked neighbors */
                  if (!CF_marker[j])
                  {
                     measure_array[j]--;
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               j = S_offd_j[jS];
               if (j > -1)
               {
             
                  /* "remove" edge from S */
                  S_offd_j[jS] = -S_offd_j[jS]-1;
               
                  /* decrement measures of unmarked neighbors */
                  if (!CF_marker_offd[j])
                  {
                     measure_array[j+num_variables]--;
                  }
               }
            }
         }
	 else
    	 {
            /* marked dependencies */
            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               j = S_diag_j[jS];
	       if (j < 0) j = -j-1;
   
               if (CF_marker[j] > 0)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_diag_j[jS] = -S_diag_j[jS]-1;
                  }
   
                  /* IMPORTANT: consider all dependencies */
                  /* temporarily modify CF_marker */
                  CF_marker[j] = COMMON_C_PT;
               }
               else if (CF_marker[j] == SF_PT)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_diag_j[jS] = -S_diag_j[jS]-1;
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               j = S_offd_j[jS];
	       if (j < 0) j = -j-1;
   
               if (CF_marker_offd[j] > 0)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_offd_j[jS] = -S_offd_j[jS]-1;
                  }
   
                  /* IMPORTANT: consider all dependencies */
                  /* temporarily modify CF_marker */
                  CF_marker_offd[j] = COMMON_C_PT;
               }
               else if (CF_marker_offd[j] == SF_PT)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_offd_j[jS] = -S_offd_j[jS]-1;
                  }
               }
            }
   
            /* unmarked dependencies */
            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               if (S_diag_j[jS] > -1)
               {
                  j = S_diag_j[jS];
   	          break_var = 1;
                  /* check for common C-pt */
                  for (kS = S_diag_i[j]; kS < S_diag_i[j+1]; kS++)
                  {
                     k = S_diag_j[kS];
		     if (k < 0) k = -k-1;
   
                     /* IMPORTANT: consider all dependencies */
                     if (CF_marker[k] == COMMON_C_PT)
                     {
                        /* "remove" edge from S and update measure*/
                        S_diag_j[jS] = -S_diag_j[jS]-1;
                        measure_array[j]--;
                        break_var = 0;
                        break;
                     }
                  }
   		  if (break_var)
                  {
                     for (kS = S_offd_i[j]; kS < S_offd_i[j+1]; kS++)
                     {
                        k = S_offd_j[kS];
		        if (k < 0) k = -k-1;
   
                        /* IMPORTANT: consider all dependencies */
                        if ( CF_marker_offd[k] == COMMON_C_PT)
                        {
                           /* "remove" edge from S and update measure*/
                           S_diag_j[jS] = -S_diag_j[jS]-1;
                           measure_array[j]--;
                           break;
                        }
                     }
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               if (S_offd_j[jS] > -1)
               {
                  j = S_offd_j[jS];
   
                  /* check for common C-pt */
                  for (kS = S_ext_i[j]; kS < S_ext_i[j+1]; kS++)
                  {
                     k = S_ext_j[kS];
   	             if (k >= 0)
   		     {
                        /* IMPORTANT: consider all dependencies */
                        if (CF_marker[k] == COMMON_C_PT)
                        {
                           /* "remove" edge from S and update measure*/
                           S_offd_j[jS] = -S_offd_j[jS]-1;
                           measure_array[j+num_variables]--;
                           break;
                        }
                     }
   		     else
   		     {
   		        kc = -k-1;
   		        if (kc > -1 && CF_marker_offd[kc] == COMMON_C_PT)
   		        {
                           /* "remove" edge from S and update measure*/
                           S_offd_j[jS] = -S_offd_j[jS]-1;
                           measure_array[j+num_variables]--;
                           break;
   		        }
   		     }
                  }
               }
            }
         }

         /* reset CF_marker */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
	 {
            j = S_diag_j[jS];
	    if (j < 0) j = -j-1;

            if (CF_marker[j] == COMMON_C_PT)
            {
               CF_marker[j] = C_PT;
            }
         }
         for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
         {
            j = S_offd_j[jS];
	    if (j < 0) j = -j-1;

            if (CF_marker_offd[j] == COMMON_C_PT)
            {
               CF_marker_offd[j] = C_PT;
            }
         }
      }
      if (debug_flag == 3)
      {
         wall_time = time_getWallclockSeconds() - wall_time;
         printf("Proc = %d    CLJP phase = %f graph_size = %d nc_offd = %d\n",
                     my_id, wall_time, graph_size, num_cols_offd);
      }
   }

   /*---------------------------------------------------
    * Clean up and return
    *---------------------------------------------------*/

   /* Reset S_matrix */
   for (i=0; i < S_diag_i[num_variables]; i++)
   {
      if (S_diag_j[i] < 0)
         S_diag_j[i] = -S_diag_j[i]-1;
   }
   for (i=0; i < S_offd_i[num_variables]; i++)
   {
      if (S_offd_j[i] < 0)
         S_offd_j[i] = -S_offd_j[i]-1;
   }
   /*for (i=0; i < num_variables; i++)
      if (CF_marker[i] == SF_PT) CF_marker[i] = F_PT;*/

   if(color_array)
     hypre_TFree(color_array);

   hypre_TFree(measure_array);
   hypre_TFree(graph_array);
   if (num_cols_offd) hypre_TFree(graph_array_offd);
   hypre_TFree(buf_data);
   hypre_TFree(int_buf_data);
   hypre_TFree(CF_marker_offd);
   if (num_procs > 1) hypre_CSRMatrixDestroy(S_ext);

   *CF_marker_ptr   = CF_marker;

   return (ierr);
}

int
hypre_BoomerAMGCoarsenCLJP_c_improved( hypre_ParCSRMatrix    *S,
				       hypre_ParCSRMatrix    *A,
				       int                    CF_init,
				       int                    debug_flag,
				       int                  **CF_marker_ptr,
				       int                    global,
				       int                    level,
				       double                *measure_array)
{
   MPI_Comm 	       comm            = hypre_ParCSRMatrixComm(S);
   hypre_ParCSRCommPkg      *comm_pkg        = hypre_ParCSRMatrixCommPkg(A);
   hypre_ParCSRCommHandle   *comm_handle;

   hypre_CSRMatrix    *S_diag          = hypre_ParCSRMatrixDiag(S);
   int                *S_diag_i        = hypre_CSRMatrixI(S_diag);
   int                *S_diag_j        = hypre_CSRMatrixJ(S_diag);

   hypre_CSRMatrix    *S_offd          = hypre_ParCSRMatrixOffd(S);
   int                *S_offd_i        = hypre_CSRMatrixI(S_offd);
   int                *S_offd_j;

   int 		      *col_map_offd    = hypre_ParCSRMatrixColMapOffd(S);
   int                 num_variables   = hypre_CSRMatrixNumRows(S_diag);
   int		       col_1 = hypre_ParCSRMatrixFirstColDiag(S);
   int		       col_n = col_1 + hypre_CSRMatrixNumCols(S_diag);
   int 		       num_cols_offd = 0;
                  
   hypre_CSRMatrix    *S_ext;
   int                *S_ext_i;
   int                *S_ext_j;

   int		       num_sends = 0;
   int  	      *int_buf_data;
   double	      *buf_data;

   int                *CF_marker;
   int                *CF_marker_offd;

   short              *color_array = NULL;
   int                num_colors;
                      
   //double             *measure_array;
   int                *graph_array;
   int                *graph_array_offd;
   int                 graph_size;
   int                 graph_offd_size;
   int                 global_graph_size;
                      
   int                 i, j, k, kc, jS, kS, ig;
   int		       index, start, my_id, num_procs, jrow, cnt;

   int                 j_start, j_stop, max_strong_connections;

   hypre_Queue         *buckets;
   hypre_QueueElement  *bucket_elements;
   int                 num_buckets;
                      
   int                 ierr = 0;
   int                 break_var = 1;

   double	    wall_time;
   int   iter = 0;

#if 0 /* debugging */
   char  filename[256];
   FILE *fp;
   int   iter = 0;
#endif

   if(!measure_array) {
     // Then the coloring needs to be done. The only time this is not needed is if
     // the calling function already has the measure_array computed. The CR function
     // does this because it calls CLJP_c several times for each level. By computing
     // the measure_array ahead of time, extra computation can be saved.
     color_array = hypre_CTAlloc(short, num_variables);

     if(global)
       parColorGraph(A, S, color_array, &num_colors, level);
     else
       seqColorGraphNew(S, color_array, &num_colors, level);
   }
   
   /*--------------------------------------------------------------
    * Compute a  ParCSR strength matrix, S.
    *
    * For now, the "strength" of dependence/influence is defined in
    * the following way: i depends on j if
    *     aij > hypre_max (k != i) aik,    aii < 0
    * or
    *     aij < hypre_min (k != i) aik,    aii >= 0
    * Then S_ij = 1, else S_ij = 0.
    *
    * NOTE: the entries are negative initially, corresponding
    * to "unaccounted-for" dependence.
    *----------------------------------------------------------------*/

   S_ext = NULL;
   if (debug_flag == 3) wall_time = time_getWallclockSeconds();
   MPI_Comm_size(comm,&num_procs);
   MPI_Comm_rank(comm,&my_id);
   if (!comm_pkg)
   {
        hypre_MatvecCommPkgCreate(A);
        comm_pkg = hypre_ParCSRMatrixCommPkg(A);
   }

   num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);

   int_buf_data = hypre_CTAlloc(int, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
   buf_data = hypre_CTAlloc(double, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
 
   num_cols_offd = hypre_CSRMatrixNumCols(S_offd);

   S_diag_j = hypre_CSRMatrixJ(S_diag);

   if (num_cols_offd)
   {
      S_offd_j = hypre_CSRMatrixJ(S_offd);
   }
   /*----------------------------------------------------------
    * Compute the measures
    *
    * The measures are currently given by the column sums of S.
    * Hence, measure_array[i] is the number of influences
    * of variable i.
    *----------------------------------------------------------*/

   if(!measure_array) {
     // Then the measure array needs to be computed. The CR function
     // computes the measure_array ahead of time to save extra
     // computation.
     measure_array = hypre_CTAlloc(double, num_variables+num_cols_offd);

     for (i=0; i < S_offd_i[num_variables]; i++) {
       measure_array[num_variables + S_offd_j[i]] += 1.0;
     }
     if (num_procs > 1)
       comm_handle = hypre_ParCSRCommHandleCreate(2, comm_pkg,
						  &measure_array[num_variables], buf_data);

/*      for (i=0; i < S_diag_i[num_variables]; i++) { */
/*        measure_array[S_diag_j[i]] += 1.0; */
/*      } */
     // Using the equivalent loop below so maximum number of
     // strong connections can be counted in same loop.
     for(i = 0; i < num_variables; i++) {
       j_start = S_diag_i[i];
       j_stop = S_diag_i[i+1];
       if(j_stop - j_start - 1 > max_strong_connections)
	 max_strong_connections = j_stop - j_start - 1;
       for(j = j_start; j < j_stop; j++) {
	 measure_array[S_diag_j[j]] ++;
       }
     }


     if (num_procs > 1)
       hypre_ParCSRCommHandleDestroy(comm_handle);
      
     index = 0;
     for (i=0; i < num_sends; i++) {
       start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
       for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
	 measure_array[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)]
	   += buf_data[index++];
     }

     for (i=num_variables; i < num_variables+num_cols_offd; i++) {
       /* This loop zeros out the measures for the off-process nodes since
	  this process is not responsible for . */
       measure_array[i] = 0;
     }
   }

   /*---------------------------------------------------
    * Initialize the bucket data structure.
    *---------------------------------------------------*/
/*    num_buckets = max_strong_connections*num_colors; */
/*    buckets = hypre_CTAlloc(hypre_Queue, num_buckets); */

/*    // Initialize the elements that go into the buckets. */
/*    bucket_elements = hypre_CTAlloc(hypre_QueueElement, num_variables); */

/*    // Add each node to the appropriate bucket. */
/*    for(i = 0; i < num_variables; i++) { */
/*      bucket_elements[i].data = i; */
/*      bucket_index = (measure_array[i]-1)*color_array[i] + color_array[i]; */
/*      enqueueElement(&bucket_elements[i], &buckets[bucket_index]); */
/*    } */








   /*---------------------------------------------------
    * Initialize the graph array
    * graph_array contains interior points in elements 0 ... num_variables-1
    * followed by boundary values
    *---------------------------------------------------*/

   graph_array = hypre_CTAlloc(int, num_variables);
   if (num_cols_offd)
      graph_array_offd = hypre_CTAlloc(int, num_cols_offd);
   else
      graph_array_offd = NULL;

   /* initialize measure array and graph array */

   for (ig = 0; ig < num_cols_offd; ig++)
      graph_array_offd[ig] = ig;

   /*---------------------------------------------------
    * Initialize the C/F marker array
    * C/F marker array contains interior points in elements 0 ...
    * num_variables-1  followed by boundary values
    *---------------------------------------------------*/

   graph_offd_size = num_cols_offd;

   if (CF_init)
   {
      CF_marker = *CF_marker_ptr;
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
         if ( (S_offd_i[i+1]-S_offd_i[i]) > 0
                 || CF_marker[i] == -1)
         {
	   if(CF_marker[i] != SF_PT)
            CF_marker[i] = 0;
         }
         if ( CF_marker[i] == Z_PT)
         {
            if (measure_array[i] >= 1.0 ||
                (S_diag_i[i+1]-S_diag_i[i]) > 0)
            {
               CF_marker[i] = 0;
               graph_array[cnt++] = i;
            }
            else
            {
               graph_size--;
               CF_marker[i] = F_PT;
            }
         }
         else if (CF_marker[i] == SF_PT)
	    measure_array[i] = 0;
         else
            graph_array[cnt++] = i;
      }
   }
   else
   {
      CF_marker = hypre_CTAlloc(int, num_variables);
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
	 CF_marker[i] = 0;
	 if ( (S_diag_i[i+1]-S_diag_i[i]) == 0
		&& (S_offd_i[i+1]-S_offd_i[i]) == 0)
	 {
	    CF_marker[i] = SF_PT;
	    measure_array[i] = 0;
	 }
	 else
            graph_array[cnt++] = i;
      }
   }
   graph_size = cnt;
   if (num_cols_offd)
      CF_marker_offd = hypre_CTAlloc(int, num_cols_offd);
   else
      CF_marker_offd = NULL;
   for (i=0; i < num_cols_offd; i++)
	CF_marker_offd[i] = 0;
  
   /*---------------------------------------------------
    * Loop until all points are either fine or coarse.
    *---------------------------------------------------*/

   if (num_procs > 1)
   {
      S_ext      = hypre_ParCSRMatrixExtractBExt(S,A,0);
      S_ext_i    = hypre_CSRMatrixI(S_ext);
      S_ext_j    = hypre_CSRMatrixJ(S_ext);
   }

   /*  compress S_ext  and convert column numbers*/

   index = 0;
   for (i=0; i < num_cols_offd; i++)
   {
      for (j=S_ext_i[i]; j < S_ext_i[i+1]; j++)
      {
	 k = S_ext_j[j];
	 if (k >= col_1 && k < col_n)
	 {
	    S_ext_j[index++] = k - col_1;
	 }
	 else
	 {
	    kc = hypre_BinarySearch(col_map_offd,k,num_cols_offd);
	    if (kc > -1) S_ext_j[index++] = -kc-1;
	 }
      }
      S_ext_i[i] = index;
   }
   for (i = num_cols_offd; i > 0; i--)
      S_ext_i[i] = S_ext_i[i-1];
   if (num_procs > 1) S_ext_i[0] = 0;

   if (debug_flag == 3)
   {
      wall_time = time_getWallclockSeconds() - wall_time;
      printf("Proc = %d    Initialize CLJP phase = %f\n",
                     my_id, wall_time);
   }

   while (1)
   {
      /*------------------------------------------------
       * Exchange boundary data, i.i. get measures and S_ext_data
       *------------------------------------------------*/

      if (num_procs > 1)
   	 comm_handle = hypre_ParCSRCommHandleCreate(2, comm_pkg,
                        &measure_array[num_variables], buf_data);

      if (num_procs > 1)
   	 hypre_ParCSRCommHandleDestroy(comm_handle);
      
      index = 0;
      for (i=0; i < num_sends; i++)
      {
         start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
         for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
            measure_array[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)]
                        += buf_data[index++];
      }

      /*------------------------------------------------
       * Set F-pts and update subgraph
       *------------------------------------------------*/
 
      if (iter || !CF_init)
      {
         for (ig = 0; ig < graph_size; ig++)
         {
            i = graph_array[ig];

            if ( (CF_marker[i] != C_PT) && (measure_array[i] < 1) )
            {
               /* set to be an F-pt */
               CF_marker[i] = F_PT;
 
	       /* make sure all dependencies have been accounted for */
               for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     CF_marker[i] = 0;
                  }
               }
               for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     CF_marker[i] = 0;
                  }
               }
            }
            if (CF_marker[i])
            {
               measure_array[i] = 0;
 
               /* take point out of the subgraph */
               graph_size--;
               graph_array[ig] = graph_array[graph_size];
               graph_array[graph_size] = i;
               ig--;
            }
         }
      }
 
      /*------------------------------------------------
       * Exchange boundary data, i.i. get measures
       *------------------------------------------------*/

      if (debug_flag == 3) wall_time = time_getWallclockSeconds();

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
        {
            jrow = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
            buf_data[index++] = measure_array[jrow];
         }
      }

      if (num_procs > 1)
      {
         comm_handle = hypre_ParCSRCommHandleCreate(1, comm_pkg, buf_data,
        	&measure_array[num_variables]);
 
         hypre_ParCSRCommHandleDestroy(comm_handle);
 
      }
      /*------------------------------------------------
       * Debugging:
       *
       * Uncomment the sections of code labeled
       * "debugging" to generate several files that
       * can be visualized using the `coarsen.m'
       * matlab routine.
       *------------------------------------------------*/

#if 0 /* debugging */
      /* print out measures */
      char filename[50];
      FILE * fp;
      sprintf(filename, "coarsen.out.measures.%04d", iter);
      fp = fopen(filename, "w");
      for (i = 0; i < num_variables; i++)
      {
         fprintf(fp, "%f\n", measure_array[i]);
      }
      fclose(fp);

      /* print out strength matrix */
      sprintf(filename, "coarsen.out.strength.%04d", iter);
      hypre_CSRMatrixPrint(S, filename);

      /* print out C/F marker */
      sprintf(filename, "coarsen.out.CF.%04d", iter);
      fp = fopen(filename, "w");
      for (i = 0; i < num_variables; i++)
      {
         fprintf(fp, "%d\n", CF_marker[i]);
      }
      fclose(fp);

      //iter++;
#endif

      /*------------------------------------------------
       * Test for convergence
       *------------------------------------------------*/

      MPI_Allreduce(&graph_size,&global_graph_size,1,MPI_INT,MPI_SUM,comm);

      if (global_graph_size == 0)
         break;

      /*------------------------------------------------
       * Pick an independent set of points with
       * maximal measure.
       *------------------------------------------------*/
      if (iter || !CF_init)
         hypre_BoomerAMGIndepSet(S, measure_array, graph_array,
				graph_size,
				graph_array_offd, graph_offd_size,
				CF_marker, CF_marker_offd);

      iter++;
      /*------------------------------------------------
       * Exchange boundary data for CF_marker
       *------------------------------------------------*/

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
                int_buf_data[index++]
                 = CF_marker[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)];
      }
 
      if (num_procs > 1)
      {
      comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data,
        CF_marker_offd);
 
      hypre_ParCSRCommHandleDestroy(comm_handle);
      }
 
      for (ig = 0; ig < graph_offd_size; ig++)
      {
         i = graph_array_offd[ig];

         if (CF_marker_offd[i] < 0)
         {
            /* take point out of the subgraph */
            graph_offd_size--;
            graph_array_offd[ig] = graph_array_offd[graph_offd_size];
            graph_array_offd[graph_offd_size] = i;
            ig--;
         }
      }
      if (debug_flag == 3)
      {
         wall_time = time_getWallclockSeconds() - wall_time;
         printf("Proc = %d  iter %d  comm. and subgraph update = %f\n",
                     my_id, iter, wall_time);
      }
      /*------------------------------------------------
       * Set C_pts and apply heuristics.
       *------------------------------------------------*/

      for (i=num_variables; i < num_variables+num_cols_offd; i++)
      {
         measure_array[i] = 0;
      }

      if (debug_flag == 3) wall_time = time_getWallclockSeconds();
      for (ig = 0; ig < graph_size; ig++)
      {
         i = graph_array[ig];

         /*---------------------------------------------
          * Heuristic: C-pts don't interpolate from
          * neighbors that influence them.
          *---------------------------------------------*/

         if (CF_marker[i] > 0)
         {
            /* set to be a C-pt */
            CF_marker[i] = C_PT;

            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               j = S_diag_j[jS];
               if (j > -1)
               {
               
                  /* "remove" edge from S */
                  S_diag_j[jS] = -S_diag_j[jS]-1;
             
                  /* decrement measures of unmarked neighbors */
                  if (!CF_marker[j])
                  {
                     measure_array[j]--;
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               j = S_offd_j[jS];
               if (j > -1)
               {
             
                  /* "remove" edge from S */
                  S_offd_j[jS] = -S_offd_j[jS]-1;
               
                  /* decrement measures of unmarked neighbors */
                  if (!CF_marker_offd[j])
                  {
                     measure_array[j+num_variables]--;
                  }
               }
            }
         }
	 else
    	 {
            /* marked dependencies */
            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               j = S_diag_j[jS];
	       if (j < 0) j = -j-1;
   
               if (CF_marker[j] > 0)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_diag_j[jS] = -S_diag_j[jS]-1;
                  }
   
                  /* IMPORTANT: consider all dependencies */
                  /* temporarily modify CF_marker */
                  CF_marker[j] = COMMON_C_PT;
               }
               else if (CF_marker[j] == SF_PT)
               {
                  if (S_diag_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_diag_j[jS] = -S_diag_j[jS]-1;
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               j = S_offd_j[jS];
	       if (j < 0) j = -j-1;
   
               if (CF_marker_offd[j] > 0)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_offd_j[jS] = -S_offd_j[jS]-1;
                  }
   
                  /* IMPORTANT: consider all dependencies */
                  /* temporarily modify CF_marker */
                  CF_marker_offd[j] = COMMON_C_PT;
               }
               else if (CF_marker_offd[j] == SF_PT)
               {
                  if (S_offd_j[jS] > -1)
                  {
                     /* "remove" edge from S */
                     S_offd_j[jS] = -S_offd_j[jS]-1;
                  }
               }
            }
   
            /* unmarked dependencies */
            for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
            {
               if (S_diag_j[jS] > -1)
               {
                  j = S_diag_j[jS];
   	          break_var = 1;
                  /* check for common C-pt */
                  for (kS = S_diag_i[j]; kS < S_diag_i[j+1]; kS++)
                  {
                     k = S_diag_j[kS];
		     if (k < 0) k = -k-1;
   
                     /* IMPORTANT: consider all dependencies */
                     if (CF_marker[k] == COMMON_C_PT)
                     {
                        /* "remove" edge from S and update measure*/
                        S_diag_j[jS] = -S_diag_j[jS]-1;
                        measure_array[j]--;
                        break_var = 0;
                        break;
                     }
                  }
   		  if (break_var)
                  {
                     for (kS = S_offd_i[j]; kS < S_offd_i[j+1]; kS++)
                     {
                        k = S_offd_j[kS];
		        if (k < 0) k = -k-1;
   
                        /* IMPORTANT: consider all dependencies */
                        if ( CF_marker_offd[k] == COMMON_C_PT)
                        {
                           /* "remove" edge from S and update measure*/
                           S_diag_j[jS] = -S_diag_j[jS]-1;
                           measure_array[j]--;
                           break;
                        }
                     }
                  }
               }
            }
            for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
            {
               if (S_offd_j[jS] > -1)
               {
                  j = S_offd_j[jS];
   
                  /* check for common C-pt */
                  for (kS = S_ext_i[j]; kS < S_ext_i[j+1]; kS++)
                  {
                     k = S_ext_j[kS];
   	             if (k >= 0)
   		     {
                        /* IMPORTANT: consider all dependencies */
                        if (CF_marker[k] == COMMON_C_PT)
                        {
                           /* "remove" edge from S and update measure*/
                           S_offd_j[jS] = -S_offd_j[jS]-1;
                           measure_array[j+num_variables]--;
                           break;
                        }
                     }
   		     else
   		     {
   		        kc = -k-1;
   		        if (kc > -1 && CF_marker_offd[kc] == COMMON_C_PT)
   		        {
                           /* "remove" edge from S and update measure*/
                           S_offd_j[jS] = -S_offd_j[jS]-1;
                           measure_array[j+num_variables]--;
                           break;
   		        }
   		     }
                  }
               }
            }
         }

         /* reset CF_marker */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++)
	 {
            j = S_diag_j[jS];
	    if (j < 0) j = -j-1;

            if (CF_marker[j] == COMMON_C_PT)
            {
               CF_marker[j] = C_PT;
            }
         }
         for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++)
         {
            j = S_offd_j[jS];
	    if (j < 0) j = -j-1;

            if (CF_marker_offd[j] == COMMON_C_PT)
            {
               CF_marker_offd[j] = C_PT;
            }
         }
      }
      if (debug_flag == 3)
      {
         wall_time = time_getWallclockSeconds() - wall_time;
         printf("Proc = %d    CLJP phase = %f graph_size = %d nc_offd = %d\n",
                     my_id, wall_time, graph_size, num_cols_offd);
      }
   }

   /*---------------------------------------------------
    * Clean up and return
    *---------------------------------------------------*/

   /* Reset S_matrix */
   for (i=0; i < S_diag_i[num_variables]; i++)
   {
      if (S_diag_j[i] < 0)
         S_diag_j[i] = -S_diag_j[i]-1;
   }
   for (i=0; i < S_offd_i[num_variables]; i++)
   {
      if (S_offd_j[i] < 0)
         S_offd_j[i] = -S_offd_j[i]-1;
   }
   /*for (i=0; i < num_variables; i++)
      if (CF_marker[i] == SF_PT) CF_marker[i] = F_PT;*/

   if(color_array)
     hypre_TFree(color_array);

   hypre_TFree(measure_array);
   hypre_TFree(graph_array);
   if (num_cols_offd) hypre_TFree(graph_array_offd);
   hypre_TFree(buf_data);
   hypre_TFree(int_buf_data);
   hypre_TFree(CF_marker_offd);
   if (num_procs > 1) hypre_CSRMatrixDestroy(S_ext);

   *CF_marker_ptr   = CF_marker;

   return (ierr);
}

/*==========================================================================
 * Ruge's coarsening algorithm                        
 *==========================================================================*/

#define C_PT 1
#define F_PT -1
#define Z_PT -2
#define SF_PT -3  /* special fine points */
#define UNDECIDED 0 


/**************************************************************
 *
 *      Ruge Coarsening routine
 *
 **************************************************************/
int
hypre_BoomerAMGCoarsenRuge( hypre_ParCSRMatrix    *S,
                            hypre_ParCSRMatrix    *A,
                            int                    measure_type,
                            int                    coarsen_type,
                            int                    debug_flag,
                            int                  **CF_marker_ptr)
{
   MPI_Comm         comm          = hypre_ParCSRMatrixComm(S);
   hypre_ParCSRCommPkg   *comm_pkg      = hypre_ParCSRMatrixCommPkg(S);
   hypre_ParCSRCommHandle *comm_handle;
   hypre_CSRMatrix *S_diag        = hypre_ParCSRMatrixDiag(S);
   hypre_CSRMatrix *S_offd        = hypre_ParCSRMatrixOffd(S);
   int             *S_i           = hypre_CSRMatrixI(S_diag);
   int             *S_j           = hypre_CSRMatrixJ(S_diag);
   int             *S_offd_i      = hypre_CSRMatrixI(S_offd);
   int             *S_offd_j;
   int              num_variables = hypre_CSRMatrixNumRows(S_diag);
   int              num_cols_offd = hypre_CSRMatrixNumCols(S_offd);
   int 	           *col_map_offd    = hypre_ParCSRMatrixColMapOffd(S);
                  
   hypre_CSRMatrix *S_ext;
   int             *S_ext_i;
   int             *S_ext_j;
                 
   hypre_CSRMatrix *ST;
   int             *ST_i;
   int             *ST_j;
                 
   int             *CF_marker;
   int             *CF_marker_offd;
   int              ci_tilde = -1;
   int              ci_tilde_mark = -1;
   int              ci_tilde_offd = -1;
   int              ci_tilde_offd_mark = -1;

   int             *measure_array;
   int             *graph_array;
   int 	           *int_buf_data;
   int 	           *ci_array;

   int              i, j, k, jS;
   int		    ji, jj, jk, jm, index;
   int		    set_empty = 1;
   int		    C_i_nonempty = 0;
   int		    num_nonzeros;
   int		    num_procs, my_id;
   int		    num_sends = 0;
   int		    first_col, start;
   int		    col_0, col_n;

   hypre_LinkList   LoL_head;
   hypre_LinkList   LoL_tail;

   int             *lists, *where;
   int              measure, new_meas;
   int              num_left, elmt;
   int              nabor, nabor_two;

   int              ierr = 0;
   int              use_commpkg_A = 0;
   int              break_var = 0;
   int              f_pnt = F_PT;
   double	    wall_time;

   if (coarsen_type < 0) coarsen_type = -coarsen_type;

   /*-------------------------------------------------------
    * Initialize the C/F marker, LoL_head, LoL_tail  arrays
    *-------------------------------------------------------*/

   LoL_head = NULL;
   LoL_tail = NULL;
   lists = hypre_CTAlloc(int, num_variables);
   where = hypre_CTAlloc(int, num_variables);

#if 0 /* debugging */
   char  filename[256];
   FILE *fp;
   int   iter = 0;
#endif

   /*--------------------------------------------------------------
    * Compute a CSR strength matrix, S.
    *
    * For now, the "strength" of dependence/influence is defined in
    * the following way: i depends on j if
    *     aij > hypre_max (k != i) aik,    aii < 0
    * or
    *     aij < hypre_min (k != i) aik,    aii >= 0
    * Then S_ij = 1, else S_ij = 0.
    *
    * NOTE: the entries are negative initially, corresponding
    * to "unaccounted-for" dependence.
    *----------------------------------------------------------------*/

   if (debug_flag == 3) wall_time = time_getWallclockSeconds();

   MPI_Comm_size(comm,&num_procs);
   MPI_Comm_rank(comm,&my_id);

   if (!comm_pkg)
   {
        use_commpkg_A = 1;
        comm_pkg = hypre_ParCSRMatrixCommPkg(A); 
   }

   if (!comm_pkg)
   {
#ifdef HYPRE_NO_GLOBAL_PARTITION
      hypre_NewCommPkgCreate(A);
#else
        hypre_MatvecCommPkgCreate(A);
#endif
        comm_pkg = hypre_ParCSRMatrixCommPkg(A); 
   }

   num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);

   if (num_cols_offd) S_offd_j = hypre_CSRMatrixJ(S_offd);

   jS = S_i[num_variables];

   ST = hypre_CSRMatrixCreate(num_variables, num_variables, jS);
   ST_i = hypre_CTAlloc(int,num_variables+1);
   ST_j = hypre_CTAlloc(int,jS);
   hypre_CSRMatrixI(ST) = ST_i;
   hypre_CSRMatrixJ(ST) = ST_j;

   /*----------------------------------------------------------
    * generate transpose of S, ST
    *----------------------------------------------------------*/

   for (i=0; i <= num_variables; i++)
      ST_i[i] = 0;
 
   for (i=0; i < jS; i++)
   {
	 ST_i[S_j[i]+1]++;
   }
   for (i=0; i < num_variables; i++)
   {
      ST_i[i+1] += ST_i[i];
   }
   for (i=0; i < num_variables; i++)
   {
      for (j=S_i[i]; j < S_i[i+1]; j++)
      {
	 index = S_j[j];
       	 ST_j[ST_i[index]] = i;
       	 ST_i[index]++;
      }
   }      
   for (i = num_variables; i > 0; i--)
   {
      ST_i[i] = ST_i[i-1];
   }
   ST_i[0] = 0;

   /*----------------------------------------------------------
    * Compute the measures
    *
    * The measures are given by the row sums of ST.
    * Hence, measure_array[i] is the number of influences
    * of variable i.
    * correct actual measures through adding influences from
    * neighbor processors
    *----------------------------------------------------------*/

   measure_array = hypre_CTAlloc(int, num_variables);

   for (i = 0; i < num_variables; i++)
   {
      measure_array[i] = ST_i[i+1]-ST_i[i];
   }

   /* special case for Falgout coarsening */
   if (coarsen_type == 6) 
   {
      f_pnt = Z_PT;
      coarsen_type = 1;
   }
   if (coarsen_type == 10)
   {
      f_pnt = Z_PT;
      coarsen_type = 11;
   }

   if ((measure_type || (coarsen_type != 1 && coarsen_type != 11)) 
		&& num_procs > 1)
   {
      if (use_commpkg_A)
         S_ext      = hypre_ParCSRMatrixExtractBExt(S,A,0);
      else
         S_ext      = hypre_ParCSRMatrixExtractBExt(S,S,0);
      S_ext_i    = hypre_CSRMatrixI(S_ext);
      S_ext_j    = hypre_CSRMatrixJ(S_ext);
      num_nonzeros = S_ext_i[num_cols_offd];
      first_col = hypre_ParCSRMatrixFirstColDiag(S);
      col_0 = first_col-1;
      col_n = col_0+num_variables;
      if (measure_type)
      {
	 for (i=0; i < num_nonzeros; i++)
         {
	    index = S_ext_j[i] - first_col;
	    if (index > -1 && index < num_variables)
		measure_array[index]++;
         } 
      } 
   }

   /*---------------------------------------------------
    * Loop until all points are either fine or coarse.
    *---------------------------------------------------*/

   if (debug_flag == 3) wall_time = time_getWallclockSeconds();

   /* first coarsening phase */

  /*************************************************************
   *
   *   Initialize the lists
   *
   *************************************************************/

   CF_marker = hypre_CTAlloc(int, num_variables);
   
   num_left = 0;
   for (j = 0; j < num_variables; j++)
   {
      if ((S_i[j+1]-S_i[j])== 0 &&
		(S_offd_i[j+1]-S_offd_i[j]) == 0)
      {
         CF_marker[j] = SF_PT;
         measure_array[j] = 0;
      }
      else
      {
         CF_marker[j] = UNDECIDED;
         num_left++;
      }
   } 

   for (j = 0; j < num_variables; j++) 
   {    
      measure = measure_array[j];
      if (CF_marker[j] != SF_PT)
      {
         if (measure > 0)
         {
            enter_on_lists(&LoL_head, &LoL_tail, measure, j, lists, where);
         }
         else
         {
            if (measure < 0) printf("negative measure!\n");
            CF_marker[j] = f_pnt;
            for (k = S_i[j]; k < S_i[j+1]; k++)
            {
               nabor = S_j[k];
               if (CF_marker[nabor] != SF_PT)
               {
                  if (nabor < j)
                  {
                     new_meas = measure_array[nabor];
	             if (new_meas > 0)
                        remove_point(&LoL_head, &LoL_tail, new_meas, 
                               nabor, lists, where);

                     new_meas = ++(measure_array[nabor]);
                     enter_on_lists(&LoL_head, &LoL_tail, new_meas,
                                 nabor, lists, where);
                  }
	          else
                  {
                     new_meas = ++(measure_array[nabor]);
                  }
               }
            }
            --num_left;
         }
      }
   }

   /****************************************************************
    *
    *  Main loop of Ruge-Stueben first coloring pass.
    *
    *  WHILE there are still points to classify DO:
    *        1) find first point, i,  on list with max_measure
    *           make i a C-point, remove it from the lists
    *        2) For each point, j,  in S_i^T,
    *           a) Set j to be an F-point
    *           b) For each point, k, in S_j
    *                  move k to the list in LoL with measure one
    *                  greater than it occupies (creating new LoL
    *                  entry if necessary)
    *        3) For each point, j,  in S_i,
    *                  move j to the list in LoL with measure one
    *                  smaller than it occupies (creating new LoL
    *                  entry if necessary)
    *
    ****************************************************************/

   while (num_left > 0)
   {
      index = LoL_head -> head;

      CF_marker[index] = C_PT;
      measure = measure_array[index];
      measure_array[index] = 0;
      --num_left;
      
      remove_point(&LoL_head, &LoL_tail, measure, index, lists, where);
  
      for (j = ST_i[index]; j < ST_i[index+1]; j++)
      {
         nabor = ST_j[j];
         if (CF_marker[nabor] == UNDECIDED)
         {
            CF_marker[nabor] = F_PT;
            measure = measure_array[nabor];

            remove_point(&LoL_head, &LoL_tail, measure, nabor, lists, where);
            --num_left;

            for (k = S_i[nabor]; k < S_i[nabor+1]; k++)
            {
               nabor_two = S_j[k];
               if (CF_marker[nabor_two] == UNDECIDED)
               {
                  measure = measure_array[nabor_two];
                  remove_point(&LoL_head, &LoL_tail, measure, 
                               nabor_two, lists, where);

                  new_meas = ++(measure_array[nabor_two]);
                 
                  enter_on_lists(&LoL_head, &LoL_tail, new_meas,
                                 nabor_two, lists, where);
               }
            }
         }
      }
      for (j = S_i[index]; j < S_i[index+1]; j++)
      {
         nabor = S_j[j];
         if (CF_marker[nabor] == UNDECIDED)
         {
            measure = measure_array[nabor];

            remove_point(&LoL_head, &LoL_tail, measure, nabor, lists, where);

            measure_array[nabor] = --measure;
	
	    if (measure > 0)
               enter_on_lists(&LoL_head, &LoL_tail, measure, nabor, 
				lists, where);
	    else
	    {
               CF_marker[nabor] = F_PT;
               --num_left;

               for (k = S_i[nabor]; k < S_i[nabor+1]; k++)
               {
                  nabor_two = S_j[k];
                  if (CF_marker[nabor_two] == UNDECIDED)
                  {
                     new_meas = measure_array[nabor_two];
                     remove_point(&LoL_head, &LoL_tail, new_meas, 
                               nabor_two, lists, where);

                     new_meas = ++(measure_array[nabor_two]);
                 
                     enter_on_lists(&LoL_head, &LoL_tail, new_meas,
                                 nabor_two, lists, where);
                  }
               }
	    }
         }
      }
   }

   hypre_TFree(measure_array);
   hypre_CSRMatrixDestroy(ST);

   if (debug_flag == 3)
   {
      wall_time = time_getWallclockSeconds() - wall_time;
      printf("Proc = %d    Coarsen 1st pass = %f\n",
                     my_id, wall_time); 
   }

   hypre_TFree(lists);
   hypre_TFree(where);
   hypre_TFree(LoL_head);
   hypre_TFree(LoL_tail);

   if (coarsen_type == 11)
   {
      *CF_marker_ptr = CF_marker;
      return 0;
   }

   /* second pass, check fine points for coarse neighbors 
      for coarsen_type = 2, the second pass includes
      off-processore boundary points */

   /*---------------------------------------------------
    * Initialize the graph array
    *---------------------------------------------------*/

   graph_array = hypre_CTAlloc(int, num_variables);

   for (i = 0; i < num_variables; i++)
   {
      graph_array[i] = -1;
   }

   if (debug_flag == 3) wall_time = time_getWallclockSeconds();

   if (coarsen_type == 2)
   {
      /*------------------------------------------------
       * Exchange boundary data for CF_marker
       *------------------------------------------------*/
    
      CF_marker_offd = hypre_CTAlloc(int, num_cols_offd);
      int_buf_data = hypre_CTAlloc(int, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                   num_sends));
    
      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
                int_buf_data[index++]
                 = CF_marker[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)];
      }
    
      if (num_procs > 1)
      {
      comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data,
        CF_marker_offd);
    
      hypre_ParCSRCommHandleDestroy(comm_handle);
      }
    
      ci_array = hypre_CTAlloc(int,num_cols_offd);
      for (i=0; i < num_cols_offd; i++)
	 ci_array[i] = -1;
	
      for (i=0; i < num_variables; i++)
      {
	 if (ci_tilde_mark |= i) ci_tilde = -1;
	 if (ci_tilde_offd_mark |= i) ci_tilde_offd = -1;
         if (CF_marker[i] == -1)
         {
            break_var = 1;
            for (ji = S_i[i]; ji < S_i[i+1]; ji++)
            {
               j = S_j[ji];
               if (CF_marker[j] > 0)
                  graph_array[j] = i;
            }
            for (ji = S_offd_i[i]; ji < S_offd_i[i+1]; ji++)
            {
               j = S_offd_j[ji];
               if (CF_marker_offd[j] > 0)
                  ci_array[j] = i;
            }
            for (ji = S_i[i]; ji < S_i[i+1]; ji++)
            {
               j = S_j[ji];
               if (CF_marker[j] == -1)
               {
                  set_empty = 1;
                  for (jj = S_i[j]; jj < S_i[j+1]; jj++)
                  {
                     index = S_j[jj];
                     if (graph_array[index] == i)
                     {
                        set_empty = 0;
                        break;
                     }
                  }
		  if (set_empty)
                  {
                     for (jj = S_offd_i[j]; jj < S_offd_i[j+1]; jj++)
                     {
                        index = S_offd_j[jj];
                        if (ci_array[index] == i)
                        {
                           set_empty = 0;
                           break;
                        }
                     }
                  } 
                  if (set_empty)
                  {
                     if (C_i_nonempty)
                     {
                        CF_marker[i] = 1;
                        if (ci_tilde > -1)
                        {
                           CF_marker[ci_tilde] = -1;
                           ci_tilde = -1;
                        }
                        if (ci_tilde_offd > -1)
                        {
                           CF_marker_offd[ci_tilde_offd] = -1;
                           ci_tilde_offd = -1;
                        }
                        C_i_nonempty = 0;
                        break_var = 0;
                        break;
                     }
                     else
                     {
                        ci_tilde = j;
                        ci_tilde_mark = i;
                        CF_marker[j] = 1;
                        C_i_nonempty = 1;
                        i--;
                        break_var = 0;
                        break;
                     }
                  }
               }
            }
            if (break_var)
            {
               for (ji = S_offd_i[i]; ji < S_offd_i[i+1]; ji++)
               {
                  j = S_offd_j[ji];
                  if (CF_marker_offd[j] == -1)
                  {
                     set_empty = 1;
                     for (jj = S_ext_i[j]; jj < S_ext_i[j+1]; jj++)
                     {
                        index = S_ext_j[jj];
                        if (index > col_0 && index < col_n) /* index interior */
                        {
                           if (graph_array[index-first_col] == i)
                           {
                              set_empty = 0;
                              break;
                           }
                        }
                        else
                        {
   		           jk = hypre_BinarySearch(col_map_offd,index,num_cols_offd);
                           if (jk != -1)
                           {
                              if (ci_array[jk] == i)
                              {
                                 set_empty = 0;
                                 break;
                              }
                           }
                        }
                     }
                     if (set_empty)
                     {
                        if (C_i_nonempty)
                        {
                           CF_marker[i] = 1;
                           if (ci_tilde > -1)
                           {
                              CF_marker[ci_tilde] = -1;
                              ci_tilde = -1;
                           }
                           if (ci_tilde_offd > -1)
                           {
                              CF_marker_offd[ci_tilde_offd] = -1;
                              ci_tilde_offd = -1;
                           }
                           C_i_nonempty = 0;
                           break;
                        }
                        else
                        {
                           ci_tilde_offd = j;
                           ci_tilde_offd_mark = i;
                           CF_marker_offd[j] = 1;
                           C_i_nonempty = 1;
                           i--;
                           break;
                        }
                     }
                  }
               }
            }
         }
      }
   }
   else
   {
      for (i=0; i < num_variables; i++)
      {
	 if (ci_tilde_mark |= i) ci_tilde = -1;
         if (CF_marker[i] == -1)
         {
   	    for (ji = S_i[i]; ji < S_i[i+1]; ji++)
   	    {
   	       j = S_j[ji];
   	       if (CF_marker[j] > 0)
   	          graph_array[j] = i;
    	    }
   	    for (ji = S_i[i]; ji < S_i[i+1]; ji++)
   	    {
   	       j = S_j[ji];
   	       if (CF_marker[j] == -1)
   	       {
   	          set_empty = 1;
   	          for (jj = S_i[j]; jj < S_i[j+1]; jj++)
   	          {
   		     index = S_j[jj];
   		     if (graph_array[index] == i)
   		     {
   		        set_empty = 0;
   		        break;
   		     }
   	          }
   	          if (set_empty)
   	          {
   		     if (C_i_nonempty)
   		     {
   		        CF_marker[i] = 1;
   		        if (ci_tilde > -1)
   		        {
   			   CF_marker[ci_tilde] = -1;
   		           ci_tilde = -1;
   		        }
   	    		C_i_nonempty = 0;
   		        break;
   		     }
   		     else
   		     {
   		        ci_tilde = j;
   		        ci_tilde_mark = i;
   		        CF_marker[j] = 1;
   		        C_i_nonempty = 1;
		        i--;
		        break;
		     }
	          }
	       }
	    }
	 }
      }
   }

   if (debug_flag == 3 && coarsen_type != 2)
   {
      wall_time = time_getWallclockSeconds() - wall_time;
      printf("Proc = %d    Coarsen 2nd pass = %f\n",
                       my_id, wall_time); 
   }

   /* third pass, check boundary fine points for coarse neighbors */

   if (coarsen_type == 3 || coarsen_type == 4)
   {
      if (debug_flag == 3) wall_time = time_getWallclockSeconds();

      CF_marker_offd = hypre_CTAlloc(int, num_cols_offd);
      int_buf_data = hypre_CTAlloc(int, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));

      /*------------------------------------------------
       * Exchange boundary data for CF_marker
       *------------------------------------------------*/

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
             int_buf_data[index++] 
              = CF_marker[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)];
      }
 
      if (num_procs > 1)
      {
      comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data, 
     		CF_marker_offd);
 
      hypre_ParCSRCommHandleDestroy(comm_handle);   
      }

      ci_array = hypre_CTAlloc(int,num_cols_offd);
      for (i=0; i < num_cols_offd; i++)
	 ci_array[i] = -1;
   }

   if (coarsen_type > 1 && coarsen_type < 5)
   { 
      for (i=0; i < num_variables; i++)
	 graph_array[i] = -1;
      for (i=0; i < num_cols_offd; i++)
      {
	 if (ci_tilde_mark |= i) ci_tilde = -1;
	 if (ci_tilde_offd_mark |= i) ci_tilde_offd = -1;
         if (CF_marker_offd[i] == -1)
         {
   	    for (ji = S_ext_i[i]; ji < S_ext_i[i+1]; ji++)
   	    {
   	       j = S_ext_j[ji];
   	       if (j > col_0 && j < col_n)
   	       {
   	          j = j - first_col;
   	          if (CF_marker[j] > 0)
   	             graph_array[j] = i;
   	       }
   	       else
   	       {
   		  jj = hypre_BinarySearch(col_map_offd,j,num_cols_offd);
   		  if (jj != -1 && CF_marker_offd[jj] > 0)
   	                ci_array[jj] = i;
    	       }	
    	    }
   	    for (ji = S_ext_i[i]; ji < S_ext_i[i+1]; ji++)
   	    {
   	       j = S_ext_j[ji];
   	       if (j > col_0 && j < col_n)
   	       {
   	          j = j - first_col;
   	          if ( CF_marker[j] == -1)
   	          {
   	             set_empty = 1;
   	             for (jj = S_i[j]; jj < S_i[j+1]; jj++)
   	             {
   		        index = S_j[jj];
   		        if (graph_array[index] == i)
   		        {
   		           set_empty = 0;
   		           break;
   		        }
   	             }
   	             for (jj = S_offd_i[j]; jj < S_offd_i[j+1]; jj++)
   	             {
   		        index = S_offd_j[jj];
   		        if (ci_array[index] == i)
   		        {
   		           set_empty = 0;
   		           break;
   		        }
   	             }
   	             if (set_empty)
   	             {
   		        if (C_i_nonempty)
   		        {
   		           CF_marker_offd[i] = 1;
   		           if (ci_tilde > -1)
   		           {
   			      CF_marker[ci_tilde] = -1;
			      ci_tilde = -1;
   		           }
   		           if (ci_tilde_offd > -1)
   		           {
   			      CF_marker_offd[ci_tilde_offd] = -1;
			      ci_tilde_offd = -1;
   		           }
                           C_i_nonempty = 0;
   		           break;
   		        }
   		        else
   		        {
   		           ci_tilde = j;
   		           ci_tilde_mark = i;
   		           CF_marker[j] = 1;
   		           C_i_nonempty = 1;
   		           i--;
   		           break;
   		        }
   	             }
   	          }
   	       }
   	       else
   	       {
   		  jm = hypre_BinarySearch(col_map_offd,j,num_cols_offd);
   		  if (jm != -1 && CF_marker_offd[jm] == -1)
   	          {
   	             set_empty = 1;
   	             for (jj = S_ext_i[jm]; jj < S_ext_i[jm+1]; jj++)
   	             {
   		        index = S_ext_j[jj];
   		        if (index > col_0 && index < col_n) 
   		  	{
   		           if (graph_array[index-first_col] == i)
   		           {
   		              set_empty = 0;
   		              break;
   		           }
   	                }
   			else
   			{
   		           jk = hypre_BinarySearch(col_map_offd,index,num_cols_offd);
   			   if (jk != -1)
   			   {
   		              if (ci_array[jk] == i)
   		              {
   		                 set_empty = 0;
   		                 break;
   		              }
   		           }
   	                }
   	             }
   	             if (set_empty)
   	             {
   		        if (C_i_nonempty)
   		        {
   		           CF_marker_offd[i] = 1;
   		           if (ci_tilde > -1)
   		           {
   			      CF_marker[ci_tilde] = -1;
   			      ci_tilde = -1;
   		           }
   		           if (ci_tilde_offd > -1)
   		           {
   			      CF_marker_offd[ci_tilde_offd] = -1;
   			      ci_tilde_offd = -1;
   		           }
                           C_i_nonempty = 0;
   		           break;
   		        }
   		        else
   		        {
   		           ci_tilde_offd = jm;
   		           ci_tilde_offd_mark = i;
   		           CF_marker_offd[jm] = 1;
   		           C_i_nonempty = 1;
   		           i--;
   		           break;
   		        }
   		     }
   	          }
   	       }
   	    }
         }
      }
      /*------------------------------------------------
       * Send boundary data for CF_marker back
       *------------------------------------------------*/
      if (num_procs > 1)
      {
      comm_handle = hypre_ParCSRCommHandleCreate(12, comm_pkg, CF_marker_offd, 
   			int_buf_data);
    
      hypre_ParCSRCommHandleDestroy(comm_handle);   
      }
   
      /* only CF_marker entries from larger procs are accepted  
	if coarsen_type = 4 coarse points are not overwritten  */
 
      index = 0;
      if (coarsen_type != 4)
      {
         for (i = 0; i < num_sends; i++)
         {
	    start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
            if (hypre_ParCSRCommPkgSendProc(comm_pkg,i) > my_id)
	    {
              for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
                   CF_marker[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)] =
                   int_buf_data[index++]; 
            }
	    else
	    {
	       index += hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1) - start;
	    }
         }
      }
      else
      {
         for (i = 0; i < num_sends; i++)
         {
	    start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
            if (hypre_ParCSRCommPkgSendProc(comm_pkg,i) > my_id)
	    {
              for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
              {
                 elmt = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
                 if (CF_marker[elmt] != 1)
                   CF_marker[elmt] = int_buf_data[index];
		 index++; 
              }
            }
	    else
	    {
	       index += hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1) - start;
	    }
         }
      }
      if (debug_flag == 3)
      {
         wall_time = time_getWallclockSeconds() - wall_time;
         if (coarsen_type == 4)
		printf("Proc = %d    Coarsen 3rd pass = %f\n",
                my_id, wall_time); 
         if (coarsen_type == 3)
		printf("Proc = %d    Coarsen 3rd pass = %f\n",
                my_id, wall_time); 
         if (coarsen_type == 2)
		printf("Proc = %d    Coarsen 2nd pass = %f\n",
                my_id, wall_time); 
      }
   }
   if (coarsen_type == 5)
   {
      /*------------------------------------------------
       * Exchange boundary data for CF_marker
       *------------------------------------------------*/

      if (debug_flag == 3) wall_time = time_getWallclockSeconds();
    
      CF_marker_offd = hypre_CTAlloc(int, num_cols_offd);
      int_buf_data = hypre_CTAlloc(int, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                   num_sends));
    
      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
                int_buf_data[index++]
                 = CF_marker[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)];
      }
    
      if (num_procs > 1)
      {
      comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data,
        CF_marker_offd);
    
      hypre_ParCSRCommHandleDestroy(comm_handle);
      }
    
      ci_array = hypre_CTAlloc(int,num_cols_offd);
      for (i=0; i < num_cols_offd; i++)
   	 ci_array[i] = -1;
      for (i=0; i < num_variables; i++)
   	 graph_array[i] = -1;

      for (i=0; i < num_variables; i++)
      {
         if (CF_marker[i] == -1 && (S_offd_i[i+1]-S_offd_i[i]) > 0)
         {
            break_var = 1;
            for (ji = S_i[i]; ji < S_i[i+1]; ji++)
            {
               j = S_j[ji];
               if (CF_marker[j] > 0)
                  graph_array[j] = i;
            }
            for (ji = S_offd_i[i]; ji < S_offd_i[i+1]; ji++)
            {
               j = S_offd_j[ji];
               if (CF_marker_offd[j] > 0)
                  ci_array[j] = i;
            }
            for (ji = S_offd_i[i]; ji < S_offd_i[i+1]; ji++)
            {
               j = S_offd_j[ji];
               if (CF_marker_offd[j] == -1)
               {
                  set_empty = 1;
                  for (jj = S_ext_i[j]; jj < S_ext_i[j+1]; jj++)
                  {
                     index = S_ext_j[jj];
                     if (index > col_0 && index < col_n) /* index interior */
                     {
                        if (graph_array[index-first_col] == i)
                        {
                           set_empty = 0;
                           break;
                        }
                     }
                     else
                     {
   		        jk = hypre_BinarySearch(col_map_offd,index,num_cols_offd);
                        if (jk != -1)
                        {
                           if (ci_array[jk] == i)
                           {
                              set_empty = 0;
                              break;
                           }
                        }
                     }
                  }
                  if (set_empty)
                  {
                     if (C_i_nonempty)
                     {
                        CF_marker[i] = -2;
                        C_i_nonempty = 0;
                        break;
                     }
                     else
                     {
                        C_i_nonempty = 1;
                        i--;
                        break;
                     }
                  }
               }
            }
         }
      }
      if (debug_flag == 3)
      {
         wall_time = time_getWallclockSeconds() - wall_time;
         printf("Proc = %d    Coarsen special points = %f\n",
                       my_id, wall_time); 
      }

   }
   /*---------------------------------------------------
    * Clean up and return
    *---------------------------------------------------*/

   if (coarsen_type != 1)
   {   
      hypre_TFree(CF_marker_offd);
      hypre_TFree(int_buf_data);
      hypre_TFree(ci_array);
   }   
   hypre_TFree(graph_array);
   if ((measure_type || (coarsen_type != 1 && coarsen_type != 11)) 
		&& num_procs > 1)
   	hypre_CSRMatrixDestroy(S_ext); 
   
   *CF_marker_ptr   = CF_marker;
   
   return (ierr);
}


int
hypre_BoomerAMGCoarsenFalgout( hypre_ParCSRMatrix    *S,
                               hypre_ParCSRMatrix    *A,
                               int                    measure_type,
                               int                    debug_flag,
                               int                  **CF_marker_ptr)
{
   int              ierr = 0;

   /*-------------------------------------------------------
    * Perform Ruge coarsening followed by CLJP coarsening
    *-------------------------------------------------------*/

   ierr += hypre_BoomerAMGCoarsenRuge (S, A, measure_type, 6, debug_flag, 
				CF_marker_ptr);

   ierr += hypre_BoomerAMGCoarsen (S, A, 1, debug_flag, 
				CF_marker_ptr);

   return (ierr);
}

int
hypre_BoomerAMGCoarsenHMIS( hypre_ParCSRMatrix    *S,
                            hypre_ParCSRMatrix    *A,
                            int                    measure_type,
                            int                    debug_flag,
                            int                  **CF_marker_ptr)
{
   int              ierr = 0;

   /*-------------------------------------------------------
    * Perform Ruge coarsening followed by CLJP coarsening
    *-------------------------------------------------------*/

   ierr += hypre_BoomerAMGCoarsenRuge (S, A, measure_type, 10, debug_flag,
                                CF_marker_ptr);

   ierr += hypre_BoomerAMGCoarsenPMIS (S, A, 1, debug_flag,
                                CF_marker_ptr);

   return (ierr);
}

/*--------------------------------------------------------------------------*/

#define C_PT  1
#define F_PT -1
#define SF_PT -3
#define COMMON_C_PT  2
#define Z_PT -2

      /* begin HANS added */
/**************************************************************
 *
 *      Modified Independent Set Coarsening routine
 *          (don't worry about strong F-F connections
 *           without a common C point)
 *
 **************************************************************/
int
hypre_BoomerAMGCoarsenPMIS( hypre_ParCSRMatrix    *S,
			    hypre_ParCSRMatrix    *A,
                        int                    CF_init,
                        int                    debug_flag,
                        int                  **CF_marker_ptr)
{
   MPI_Comm 	       comm            = hypre_ParCSRMatrixComm(S);
   hypre_ParCSRCommPkg      *comm_pkg        = hypre_ParCSRMatrixCommPkg(S);
   hypre_ParCSRCommHandle   *comm_handle;

   hypre_CSRMatrix    *S_diag          = hypre_ParCSRMatrixDiag(S);
   int                *S_diag_i        = hypre_CSRMatrixI(S_diag);
   int                *S_diag_j        = hypre_CSRMatrixJ(S_diag);

   hypre_CSRMatrix    *S_offd          = hypre_ParCSRMatrixOffd(S);
   int                *S_offd_i        = hypre_CSRMatrixI(S_offd);
   int                *S_offd_j;

   int                 num_variables   = hypre_CSRMatrixNumRows(S_diag);
   int 		       num_cols_offd = 0;
                  
   /* hypre_CSRMatrix    *S_ext;
   int                *S_ext_i;
   int                *S_ext_j; */

   int		       num_sends = 0;
   int  	      *int_buf_data;
   double	      *buf_data;

   int                *CF_marker;
   int                *CF_marker_offd;
                      
   double             *measure_array;
   int                *graph_array;
   int                *graph_array_offd;
   int                 graph_size;
   int                 graph_offd_size;
   int                 global_graph_size;
                      
   int                 i, j, jS, ig;
   int		       index, start, my_id, num_procs, jrow, cnt, elmt;
                      
   int                 ierr = 0;

   double	    wall_time;
   int   iter = 0;



#if 0 /* debugging */
   char  filename[256];
   FILE *fp;
   int   iter = 0;
#endif

   /*******************************************************************************
    BEFORE THE INDEPENDENT SET COARSENING LOOP:
      measure_array: calculate the measures, and communicate them
        (this array contains measures for both local and external nodes)
      CF_marker, CF_marker_offd: initialize CF_marker
        (separate arrays for local and external; 0=unassigned, negative=F point, positive=C point)
   ******************************************************************************/      

   /*--------------------------------------------------------------
    * Use the ParCSR strength matrix, S.
    *
    * For now, the "strength" of dependence/influence is defined in
    * the following way: i depends on j if
    *     aij > hypre_max (k != i) aik,    aii < 0
    * or
    *     aij < hypre_min (k != i) aik,    aii >= 0
    * Then S_ij = 1, else S_ij = 0.
    *
    * NOTE: S_data is not used; in stead, only strong columns are retained
    *       in S_j, which can then be used like S_data
    *----------------------------------------------------------------*/

   /*S_ext = NULL; */
   if (debug_flag == 3) wall_time = time_getWallclockSeconds();
   MPI_Comm_size(comm,&num_procs);
   MPI_Comm_rank(comm,&my_id);

   if (!comm_pkg)
   {
        comm_pkg = hypre_ParCSRMatrixCommPkg(A); 
   }

   if (!comm_pkg)
   {
#ifdef HYPRE_NO_GLOBAL_PARTITION
      hypre_NewCommPkgCreate(A);
#else
        hypre_MatvecCommPkgCreate(A);
#endif
        comm_pkg = hypre_ParCSRMatrixCommPkg(A); 
   }

   num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);

   int_buf_data = hypre_CTAlloc(int, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
   buf_data = hypre_CTAlloc(double, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
 
   num_cols_offd = hypre_CSRMatrixNumCols(S_offd);

   S_diag_j = hypre_CSRMatrixJ(S_diag);

   if (num_cols_offd)
   {
      S_offd_j = hypre_CSRMatrixJ(S_offd);
   }

   /*----------------------------------------------------------
    * Compute the measures
    *
    * The measures are currently given by the column sums of S.
    * Hence, measure_array[i] is the number of influences
    * of variable i.
    *
    * The measures are augmented by a random number
    * between 0 and 1.
    *----------------------------------------------------------*/

   measure_array = hypre_CTAlloc(double, num_variables+num_cols_offd);

   /* first calculate the local part of the sums for the external nodes */
   for (i=0; i < S_offd_i[num_variables]; i++)
   { 
      measure_array[num_variables + S_offd_j[i]] += 1.0;
   }

   /* now send those locally calculated values for the external nodes to the neighboring processors */
   if (num_procs > 1)
   comm_handle = hypre_ParCSRCommHandleCreate(2, comm_pkg, 
                        &measure_array[num_variables], buf_data);

   /* calculate the local part for the local nodes */
   for (i=0; i < S_diag_i[num_variables]; i++)
   { 
      measure_array[S_diag_j[i]] += 1.0;
   }

   /* finish the communication */
   if (num_procs > 1)
   hypre_ParCSRCommHandleDestroy(comm_handle);
      
   /* now add the externally calculated part of the local nodes to the local nodes */
   index = 0;
   for (i=0; i < num_sends; i++)
   {
      start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
      for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
            measure_array[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)]
                        += buf_data[index++];
   }

   /* set the measures of the external nodes to zero */
   for (i=num_variables; i < num_variables+num_cols_offd; i++)
   { 
      measure_array[i] = 0;
   }

   /* this augments the measures with a random number between 0 and 1 */
   /* (only for the local part) */
   /* this augments the measures */
   if (CF_init == 2)
      hypre_BoomerAMGIndepSetInit(S, measure_array, 1);
   else
      hypre_BoomerAMGIndepSetInit(S, measure_array, 0);

   /*---------------------------------------------------
    * Initialize the graph arrays, and CF_marker arrays
    *---------------------------------------------------*/

   /* first the off-diagonal part of the graph array */
   if (num_cols_offd) 
      graph_array_offd = hypre_CTAlloc(int, num_cols_offd);
   else
      graph_array_offd = NULL;

   for (ig = 0; ig < num_cols_offd; ig++)
      graph_array_offd[ig] = ig;

   graph_offd_size = num_cols_offd;

   /* now the local part of the graph array, and the local CF_marker array */
   graph_array = hypre_CTAlloc(int, num_variables);

   if (CF_init==1)
   { 
      CF_marker = *CF_marker_ptr;
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
         if ( (S_offd_i[i+1]-S_offd_i[i]) > 0 || CF_marker[i] == -1)
	 {
	   if(CF_marker[i] != SF_PT) CF_marker[i] = 0;
	   //CF_marker[i] = 0; // I commented this line and added the one above. -David Alber
	 }
         if ( CF_marker[i] == Z_PT)
         {
            if (measure_array[i] >= 1.0 ||
                (S_diag_i[i+1]-S_diag_i[i]) > 0)
            {
               CF_marker[i] = 0;
               graph_array[cnt++] = i;
            }
            else
            {
               CF_marker[i] = F_PT;
            }
         }
         else if (CF_marker[i] == SF_PT)
            measure_array[i] = 0;
         else
            graph_array[cnt++] = i;
      }
   }
   else
   {
      CF_marker = hypre_CTAlloc(int, num_variables);
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
         CF_marker[i] = 0;
         if ( (S_diag_i[i+1]-S_diag_i[i]) == 0
                && (S_offd_i[i+1]-S_offd_i[i]) == 0)
         {
            CF_marker[i] = SF_PT;
            measure_array[i] = 0;
         }
         else
            graph_array[cnt++] = i;
      }
   }
   graph_size = cnt;

   /* now the off-diagonal part of CF_marker */
   if (num_cols_offd)
     CF_marker_offd = hypre_CTAlloc(int, num_cols_offd);
   else
     CF_marker_offd = NULL;

   for (i=0; i < num_cols_offd; i++)
	CF_marker_offd[i] = 0;
  
   /*------------------------------------------------
    * Communicate the local measures, which are complete,
      to the external nodes
    *------------------------------------------------*/
   index = 0;
   for (i = 0; i < num_sends; i++)
     {
       start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
       for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
	 {
	   jrow = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
	   buf_data[index++] = measure_array[jrow];
         }
     }
   
   if (num_procs > 1)
     { 
       comm_handle = hypre_ParCSRCommHandleCreate(1, comm_pkg, buf_data, 
						  &measure_array[num_variables]);
       
       hypre_ParCSRCommHandleDestroy(comm_handle);   
       
     } 
      
   /* we need S_ext: the columns of the S matrix for the local nodes */
   /* we need this because the independent set routine can only decide
      which local nodes are in it when it knows both the rows and columns
      of S */

   /* if (num_procs > 1)
   {
      S_ext      = hypre_ParCSRMatrixExtractBExt(S,A,0);
      S_ext_i    = hypre_CSRMatrixI(S_ext);
      S_ext_j    = hypre_CSRMatrixJ(S_ext);
   } */

   /*  compress S_ext and convert column numbers*/

   /* index = 0;
   for (i=0; i < num_cols_offd; i++)
   {
      for (j=S_ext_i[i]; j < S_ext_i[i+1]; j++)
      {
	 k = S_ext_j[j];
	 if (k >= col_1 && k < col_n)
	 {
	    S_ext_j[index++] = k - col_1;
	 }
	 else
	 {
	    kc = hypre_BinarySearch(col_map_offd,k,num_cols_offd);
	    if (kc > -1) S_ext_j[index++] = -kc-1;
	 }
      }
      S_ext_i[i] = index;
   }
   for (i = num_cols_offd; i > 0; i--)
      S_ext_i[i] = S_ext_i[i-1];
   if (num_procs > 1) S_ext_i[0] = 0; */
 
   if (debug_flag == 3)
   {
      wall_time = time_getWallclockSeconds() - wall_time;
      printf("Proc = %d    Initialize CLJP phase = %f\n",
                     my_id, wall_time); 
   }

   /*******************************************************************************
    THE INDEPENDENT SET COARSENING LOOP:
   ******************************************************************************/      

   /*---------------------------------------------------
    * Loop until all points are either fine or coarse.
    *---------------------------------------------------*/

   while (1)
   {

     /* stop the coarsening if nothing left to be coarsened */
     MPI_Allreduce(&graph_size,&global_graph_size,1,MPI_INT,MPI_SUM,comm);

     if (global_graph_size == 0)
       break;

     /*     printf("\n");
     printf("*** MIS iteration %d\n",iter);
     printf("graph_size remaining %d\n",graph_size);*/

     /*------------------------------------------------
      * Pick an independent set of points with
      * maximal measure.
        At the end, CF_marker is complete, but still needs to be
        communicated to CF_marker_offd
      *------------------------------------------------*/
      if (!CF_init || iter)
      {
          hypre_BoomerAMGIndepSet(S, measure_array, graph_array, 
				graph_size, 
				graph_array_offd, graph_offd_size, 
				CF_marker, CF_marker_offd);

      /*------------------------------------------------
       * Exchange boundary data for CF_marker: send internal
         points to external points
       *------------------------------------------------*/

      if (num_procs > 1)
      {
// set barrier and see if all processes make it to here
         comm_handle = hypre_ParCSRCommHandleCreate(12, comm_pkg, 
		CF_marker_offd, int_buf_data);
 
         hypre_ParCSRCommHandleDestroy(comm_handle);   
      }

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
         start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
         for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
         {
            elmt = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
            if (!int_buf_data[index] && CF_marker[elmt] > 0)
            {
               CF_marker[elmt] = 0; 
               index++;
            }
            else
            {
               int_buf_data[index++] = CF_marker[elmt];
            }
         }
      }
 
      if (num_procs > 1)
      {
         comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data, 
        	CF_marker_offd);
 
         hypre_ParCSRCommHandleDestroy(comm_handle);   
      }
      }

      iter++;
     /*------------------------------------------------
      * Set C-pts and F-pts.
      *------------------------------------------------*/

     for (ig = 0; ig < graph_size; ig++) {
       i = graph_array[ig];

       /*---------------------------------------------
	* If the measure of i is smaller than 1, then
        * make i and F point (because it does not influence
        * any other point), and remove all edges of
	* equation i.
	*---------------------------------------------*/

       if(measure_array[i]<1.){
	 /* make point i an F point*/
	 CF_marker[i]= F_PT;

         /* remove the edges in equation i */
	 /* first the local part */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	   j = S_diag_j[jS];
	   if (j > -1){ /* column number is still positive; not accounted for yet */
	     S_diag_j[jS]  = -S_diag_j[jS]-1;
	   }
	 }
	 /* now the external part */
	 for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	   j = S_offd_j[jS];
	   if (j > -1){ /* column number is still positive; not accounted for yet */
	     S_offd_j[jS]  = -S_offd_j[jS]-1;
	   }
	 }
       }

       /*---------------------------------------------
	* First treat the case where point i is in the
	* independent set: make i a C point, 
        * take out all the graph edges for
        * equation i.
	*---------------------------------------------*/
       
       if (CF_marker[i] > 0) {
	 /* set to be a C-pt */
	 CF_marker[i] = C_PT;

         /* remove the edges in equation i */
	 /* first the local part */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	   j = S_diag_j[jS];
	   if (j > -1){ /* column number is still positive; not accounted for yet */
	     S_diag_j[jS]  = -S_diag_j[jS]-1;
	   }
	 }
	 /* now the external part */
	 for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	   j = S_offd_j[jS];
	   if (j > -1){ /* column number is still positive; not accounted for yet */
	     S_offd_j[jS]  = -S_offd_j[jS]-1;
	   }
	 }
       }  

       /*---------------------------------------------
	* Now treat the case where point i is not in the
	* independent set: loop over
	* all the points j that influence equation i; if
	* j is a C point, then make i an F point.
	* If i is a new F point, then remove all the edges
        * from the graph for equation i.
	*---------------------------------------------*/

       else {

	 /* first the local part */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	   /* j is the column number, or the local number of the point influencing i */
	   j = S_diag_j[jS];
           if(j<0) j=-j-1;

	   if (CF_marker[j] > 0){ /* j is a C-point */
	     CF_marker[i] = F_PT;
	   }
	 }
	 /* now the external part */
	 for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	   j = S_offd_j[jS];
           if(j<0) j=-j-1;
	   if (CF_marker_offd[j] > 0){ /* j is a C-point */
	     CF_marker[i] = F_PT;
	   }
	 }

         /* remove all the edges for equation i if i is a new F point */
	 if (CF_marker[i] == F_PT){
	   /* first the local part */
	   for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	     j = S_diag_j[jS];
	     if (j > -1){ /* column number is still positive; not accounted for yet */
	       S_diag_j[jS]  = -S_diag_j[jS]-1;
	     }
	   }
	   /* now the external part */
	   for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	     j = S_offd_j[jS];
	     if (j > -1){ /* column number is still positive; not accounted for yet */
	       S_offd_j[jS]  = -S_offd_j[jS]-1;
	     }
	   }
	 }   
       } /* end else */
     } /* end first loop over graph */

     /* now communicate CF_marker to CF_marker_offd, to make
        sure that new external F points are known on this processor */

      /*------------------------------------------------
       * Exchange boundary data for CF_marker: send internal
         points to external points
       *------------------------------------------------*/

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
                int_buf_data[index++] 
                 = CF_marker[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)];
      }
 
      if (num_procs > 1)
      {
      comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data, 
        CF_marker_offd);
 
      hypre_ParCSRCommHandleDestroy(comm_handle);   
      }

     /*---------------------------------------------
      * Now loop over the points i in the unassigned
      * graph again. For all points i that are no new C or
      * F points, remove the edges in equation i that
      * connect to C or F points.
      * (We have removed the rows for the new C and F
      * points above; now remove the columns.)
      *---------------------------------------------*/

     for (ig = 0; ig < graph_size; ig++) {
       i = graph_array[ig];

       if(CF_marker[i]==0) {

	 /* first the local part */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	   j = S_diag_j[jS];
           if(j<0) j=-j-1;

	   if (!CF_marker[j]==0 && S_diag_j[jS] > -1){ /* connection to C or F point, and
                                                 column number is still positive; not accounted for yet */
	     S_diag_j[jS]  = -S_diag_j[jS]-1;
	   }
	 }
	 /* now the external part */
	 for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	   j = S_offd_j[jS];
           if(j<0) j=-j-1;

	   if (!CF_marker_offd[j]==0 && S_offd_j[jS] > -1){ /* connection to C or F point, and
                                                 column number is still positive; not accounted for yet */
	     S_offd_j[jS]  = -S_offd_j[jS]-1;
	   }
	 }
       }
     } /* end second loop over graph */

     /*------------------------------------------------
      * Update subgraph
      *------------------------------------------------*/

     for (ig = 0; ig < graph_size; ig++) {
       i = graph_array[ig];
       
       if (!CF_marker[i]==0) /* C or F point */
	 {
	   /* the independent set subroutine needs measure 0 for
              removed nodes */
	   measure_array[i] = 0;
	   /* take point out of the subgraph */
	   graph_size--;
	   graph_array[ig] = graph_array[graph_size];
	   graph_array[graph_size] = i;
	   ig--;
	 }
     }
     for (ig = 0; ig < graph_offd_size; ig++) {
       i = graph_array_offd[ig];
       
       if (!CF_marker_offd[i]==0) /* C or F point */
	 {
	   /* the independent set subroutine needs measure 0 for
              removed nodes */
	   measure_array[i+num_variables] = 0;
	   /* take point out of the subgraph */
	   graph_offd_size--;
	   graph_array_offd[ig] = graph_array_offd[graph_offd_size];
	   graph_array_offd[graph_offd_size] = i;
	   ig--;
	 }
     }
     
   } /* end while */

   /*   printf("*** MIS iteration %d\n",iter);
   printf("graph_size remaining %d\n",graph_size);

   printf("num_cols_offd %d\n",num_cols_offd);
   for (i=0;i<num_variables;i++)
     {
              if(CF_marker[i]==1)
       printf("node %d CF %d\n",i,CF_marker[i]);
       }*/


   /*---------------------------------------------------
    * Clean up and return
    *---------------------------------------------------*/

   /* Reset S_matrix */
   for (i=0; i < S_diag_i[num_variables]; i++)
   {
      if (S_diag_j[i] < 0)
         S_diag_j[i] = -S_diag_j[i]-1;
   }
   for (i=0; i < S_offd_i[num_variables]; i++)
   {
      if (S_offd_j[i] < 0)
         S_offd_j[i] = -S_offd_j[i]-1;
   }
   /*for (i=0; i < num_variables; i++)
      if (CF_marker[i] == SF_PT) CF_marker[i] = F_PT;*/

   hypre_TFree(measure_array);
   hypre_TFree(graph_array);
   if (num_cols_offd) hypre_TFree(graph_array_offd);
   hypre_TFree(buf_data);
   hypre_TFree(int_buf_data);
   hypre_TFree(CF_marker_offd);
   /*if (num_procs > 1) hypre_CSRMatrixDestroy(S_ext);*/

   *CF_marker_ptr   = CF_marker;

   return (ierr);
}

/**************************************************************
 *
 *      Modified Independent Set Coarsening routine
 *          (don't worry about strong F-F connections
 *           without a common C point)
 *
 *      Pre-color the graph using same technique as in
 *          CLJP-c.
 *
 **************************************************************/
int
hypre_BoomerAMGCoarsenPMIS_c( hypre_ParCSRMatrix    *S,
			      hypre_ParCSRMatrix    *A,
			      int                    CF_init,
			      int                    debug_flag,
			      int                  **CF_marker_ptr,
			      int                    global,
                              int                    level,
			      int                    distance_one_color,
			      double                *measure_array)
{
   MPI_Comm 	       comm            = hypre_ParCSRMatrixComm(S);
   hypre_ParCSRCommPkg      *comm_pkg        = hypre_ParCSRMatrixCommPkg(S);
   hypre_ParCSRCommHandle   *comm_handle;

   hypre_CSRMatrix    *S_diag          = hypre_ParCSRMatrixDiag(S);
   int                *S_diag_i        = hypre_CSRMatrixI(S_diag);
   int                *S_diag_j        = hypre_CSRMatrixJ(S_diag);

   hypre_CSRMatrix    *S_offd          = hypre_ParCSRMatrixOffd(S);
   int                *S_offd_i        = hypre_CSRMatrixI(S_offd);
   int                *S_offd_j;

   int                 num_variables   = hypre_CSRMatrixNumRows(S_diag);
   int 		       num_cols_offd = 0;
                  
   /* hypre_CSRMatrix    *S_ext;
   int                *S_ext_i;
   int                *S_ext_j; */

   int		       num_sends = 0;
   int  	      *int_buf_data;
   double	      *buf_data;

   int                *CF_marker;
   int                *CF_marker_offd;
                      
   short              *color_array;
   int                num_colors;
                      
   //double             *measure_array;
   int                *graph_array;
   int                *graph_array_offd;
   int                 graph_size;
   int                 graph_offd_size;
   int                 global_graph_size;
                      
   int                 i, j, jS, ig;
   int		       index, start, my_id, num_procs, jrow, cnt, elmt;
                      
   int                 ierr = 0;
   int                 use_commpkg_A = 0;

   double	    wall_time;
   int   iter = 0;



#if 0 /* debugging */
   char  filename[256];
   FILE *fp;
   int   iter = 0;
#endif

   /*******************************************************************************
    BEFORE THE INDEPENDENT SET COARSENING LOOP:
      measure_array: calculate the measures, and communicate them
        (this array contains measures for both local and external nodes)
      CF_marker, CF_marker_offd: initialize CF_marker
        (separate arrays for local and external; 0=unassigned, negative=F point, positive=C point)
   ******************************************************************************/      

   if(!measure_array) {
     // Then the coloring needs to be done. The only time this is not needed is if
     // the calling function already has the measure_array computed. The CR function
     // does this because it calls CLJP_c several times for each level. By computing
     // the measure_array ahead of time, extra computation can be saved.
     color_array = hypre_CTAlloc(short, num_variables);

     if(global)
       parColorGraph(A, S, color_array, &num_colors, level);
     else if (distance_one_color)
       seqColorGraphNew(S, color_array, &num_colors, level);
     else
       seqColorGraphD2(S, color_array, &num_colors, level);
   }
   
   /*--------------------------------------------------------------
    * Use the ParCSR strength matrix, S.
    *
    * For now, the "strength" of dependence/influence is defined in
    * the following way: i depends on j if
    *     aij > hypre_max (k != i) aik,    aii < 0
    * or
    *     aij < hypre_min (k != i) aik,    aii >= 0
    * Then S_ij = 1, else S_ij = 0.
    *
    * NOTE: S_data is not used; in stead, only strong columns are retained
    *       in S_j, which can then be used like S_data
    *----------------------------------------------------------------*/

   /*S_ext = NULL; */
   if (debug_flag == 3) wall_time = time_getWallclockSeconds();
   MPI_Comm_size(comm,&num_procs);
   MPI_Comm_rank(comm,&my_id);

   if (!comm_pkg)
   {
        use_commpkg_A = 1;
        comm_pkg = hypre_ParCSRMatrixCommPkg(A); 
   }

   if (!comm_pkg)
   {
        hypre_MatvecCommPkgCreate(A);
        comm_pkg = hypre_ParCSRMatrixCommPkg(A); 
   }

   num_sends = hypre_ParCSRCommPkgNumSends(comm_pkg);

   int_buf_data = hypre_CTAlloc(int, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
   buf_data = hypre_CTAlloc(double, hypre_ParCSRCommPkgSendMapStart(comm_pkg,
                                                num_sends));
 
   num_cols_offd = hypre_CSRMatrixNumCols(S_offd);

   S_diag_j = hypre_CSRMatrixJ(S_diag);

   if (num_cols_offd)
   {
      S_offd_j = hypre_CSRMatrixJ(S_offd);
   }

   /*----------------------------------------------------------
    * Compute the measures
    *
    * The measures are currently given by the column sums of S.
    * Hence, measure_array[i] is the number of influences
    * of variable i.
    *
    * The measures are augmented by a random number
    * between 0 and 1.
    *----------------------------------------------------------*/

   if(!measure_array) {
     // Then the measure array needs to be computed. The CR function
     // computes the measure_array ahead of time to save extra
     // computation.
   measure_array = hypre_CTAlloc(double, num_variables+num_cols_offd);

   /* first calculate the local part of the sums for the external nodes */
   for (i=0; i < S_offd_i[num_variables]; i++)
   { 
      measure_array[num_variables + S_offd_j[i]] += 1.0;
   }

   /* now send those locally calculated values for the external nodes to the neighboring processors */
   if (num_procs > 1)
   comm_handle = hypre_ParCSRCommHandleCreate(2, comm_pkg, 
                        &measure_array[num_variables], buf_data);

   /* calculate the local part for the local nodes */
   for (i=0; i < S_diag_i[num_variables]; i++)
   { 
      measure_array[S_diag_j[i]] += 1.0;
   }

   /* finish the communication */
   if (num_procs > 1)
   hypre_ParCSRCommHandleDestroy(comm_handle);
      
   /* now add the externally calculated part of the local nodes to the local nodes */
   index = 0;
   for (i=0; i < num_sends; i++)
   {
      start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
      for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
            measure_array[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)]
                        += buf_data[index++];
   }

   /* set the measures of the external nodes to zero */
   for (i=num_variables; i < num_variables+num_cols_offd; i++)
   { 
      measure_array[i] = 0;
   }

   /* this augments the measures with a random number between 0 and 1 */
   /* (only for the local part) */
   //hypre_BoomerAMGIndepSetInit(S, measure_array, CF_init);
   hypre_BoomerAMGIndepSetInitb(S, measure_array, color_array, num_colors);
   }

   /*---------------------------------------------------
    * Initialize the graph arrays, and CF_marker arrays
    *---------------------------------------------------*/

   /* first the off-diagonal part of the graph array */
   if (num_cols_offd) 
      graph_array_offd = hypre_CTAlloc(int, num_cols_offd);
   else
      graph_array_offd = NULL;

   for (ig = 0; ig < num_cols_offd; ig++)
      graph_array_offd[ig] = ig;

   graph_offd_size = num_cols_offd;

   /* now the local part of the graph array, and the local CF_marker array */
   graph_array = hypre_CTAlloc(int, num_variables);

   if (CF_init==1)
   { 
      CF_marker = *CF_marker_ptr;
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
         if ( (S_offd_i[i+1]-S_offd_i[i]) > 0 || CF_marker[i] == -1)
	 {
	   if(CF_marker[i] != SF_PT) CF_marker[i] = 0;
	   //CF_marker[i] = 0;
	 }
         if ( CF_marker[i] == Z_PT)
         {
            if (measure_array[i] >= 1.0 ||
                (S_diag_i[i+1]-S_diag_i[i]) > 0)
            {
               CF_marker[i] = 0;
               graph_array[cnt++] = i;
            }
            else
            {
               CF_marker[i] = F_PT;
            }
         }
         else if (CF_marker[i] == SF_PT)
            measure_array[i] = 0;
         else
            graph_array[cnt++] = i;
      }
   }
   else
   {
      CF_marker = hypre_CTAlloc(int, num_variables);
      cnt = 0;
      for (i=0; i < num_variables; i++)
      {
         CF_marker[i] = 0;
         if ( (S_diag_i[i+1]-S_diag_i[i]) == 0
                && (S_offd_i[i+1]-S_offd_i[i]) == 0)
         {
            CF_marker[i] = SF_PT;
            measure_array[i] = 0;
         }
         else
            graph_array[cnt++] = i;
      }
   }
   graph_size = cnt;

   /* now the off-diagonal part of CF_marker */
   if (num_cols_offd)
     CF_marker_offd = hypre_CTAlloc(int, num_cols_offd);
   else
     CF_marker_offd = NULL;

   for (i=0; i < num_cols_offd; i++)
	CF_marker_offd[i] = 0;
  
   /*------------------------------------------------
    * Communicate the local measures, which are complete,
      to the external nodes
    *------------------------------------------------*/
   index = 0;
   for (i = 0; i < num_sends; i++)
     {
       start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
       for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
	 {
	   jrow = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
	   buf_data[index++] = measure_array[jrow];
         }
     }
   
   if (num_procs > 1)
     { 
       comm_handle = hypre_ParCSRCommHandleCreate(1, comm_pkg, buf_data, 
						  &measure_array[num_variables]);
       
       hypre_ParCSRCommHandleDestroy(comm_handle);   
       
     } 
      
   /* we need S_ext: the columns of the S matrix for the local nodes */
   /* we need this because the independent set routine can only decide
      which local nodes are in it when it knows both the rows and columns
      of S */

   /* if (num_procs > 1)
   {
      S_ext      = hypre_ParCSRMatrixExtractBExt(S,A,0);
      S_ext_i    = hypre_CSRMatrixI(S_ext);
      S_ext_j    = hypre_CSRMatrixJ(S_ext);
   } */

   /*  compress S_ext and convert column numbers*/

   /* index = 0;
   for (i=0; i < num_cols_offd; i++)
   {
      for (j=S_ext_i[i]; j < S_ext_i[i+1]; j++)
      {
	 k = S_ext_j[j];
	 if (k >= col_1 && k < col_n)
	 {
	    S_ext_j[index++] = k - col_1;
	 }
	 else
	 {
	    kc = hypre_BinarySearch(col_map_offd,k,num_cols_offd);
	    if (kc > -1) S_ext_j[index++] = -kc-1;
	 }
      }
      S_ext_i[i] = index;
   }
   for (i = num_cols_offd; i > 0; i--)
      S_ext_i[i] = S_ext_i[i-1];
   if (num_procs > 1) S_ext_i[0] = 0; */
 
   if (debug_flag == 3)
   {
      wall_time = time_getWallclockSeconds() - wall_time;
      printf("Proc = %d    Initialize CLJP phase = %f\n",
                     my_id, wall_time); 
   }

   /*******************************************************************************
    THE INDEPENDENT SET COARSENING LOOP:
   ******************************************************************************/      

   /*---------------------------------------------------
    * Loop until all points are either fine or coarse.
    *---------------------------------------------------*/

   while (1)
   {

     /* stop the coarsening if nothing left to be coarsened */
     MPI_Allreduce(&graph_size,&global_graph_size,1,MPI_INT,MPI_SUM,comm);

     if (global_graph_size == 0)
       break;

     /*     printf("\n");
     printf("*** MIS iteration %d\n",iter);
     printf("graph_size remaining %d\n",graph_size);*/

     /*------------------------------------------------
      * Pick an independent set of points with
      * maximal measure.
        At the end, CF_marker is complete, but still needs to be
        communicated to CF_marker_offd
      *------------------------------------------------*/
      if (!CF_init || iter)
      {
          hypre_BoomerAMGIndepSet(S, measure_array, graph_array, 
				graph_size, 
				graph_array_offd, graph_offd_size, 
				CF_marker, CF_marker_offd);

      /*------------------------------------------------
       * Exchange boundary data for CF_marker: send internal
         points to external points
       *------------------------------------------------*/

      if (num_procs > 1)
      {
         comm_handle = hypre_ParCSRCommHandleCreate(12, comm_pkg, 
		CF_marker_offd, int_buf_data);
 
         hypre_ParCSRCommHandleDestroy(comm_handle);   
      }

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
         start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
         for (j=start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
         {
            elmt = hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j);
            if (!int_buf_data[index] && CF_marker[elmt] > 0)
            {
               CF_marker[elmt] = 0; 
               index++;
            }
            else
            {
               int_buf_data[index++] = CF_marker[elmt];
            }
         }
      }
 
      if (num_procs > 1)
      {
         comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data, 
        	CF_marker_offd);
 
         hypre_ParCSRCommHandleDestroy(comm_handle);   
      }
      }

      iter++;
     /*------------------------------------------------
      * Set C-pts and F-pts.
      *------------------------------------------------*/

     for (ig = 0; ig < graph_size; ig++) {
       i = graph_array[ig];

       /*---------------------------------------------
	* If the measure of i is smaller than 1, then
        * make i and F point (because it does not influence
        * any other point), and remove all edges of
	* equation i.
	*---------------------------------------------*/

       if(measure_array[i]<1.){
	 /* make point i an F point*/
	 CF_marker[i]= F_PT;

         /* remove the edges in equation i */
	 /* first the local part */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	   j = S_diag_j[jS];
	   if (j > -1){ /* column number is still positive; not accounted for yet */
	     S_diag_j[jS]  = -S_diag_j[jS]-1;
	   }
	 }
	 /* now the external part */
	 for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	   j = S_offd_j[jS];
	   if (j > -1){ /* column number is still positive; not accounted for yet */
	     S_offd_j[jS]  = -S_offd_j[jS]-1;
	   }
	 }
       }

       /*---------------------------------------------
	* First treat the case where point i is in the
	* independent set: make i a C point, 
        * take out all the graph edges for
        * equation i.
	*---------------------------------------------*/
       
       if (CF_marker[i] > 0) {
	 /* set to be a C-pt */
	 CF_marker[i] = C_PT;

         /* remove the edges in equation i */
	 /* first the local part */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	   j = S_diag_j[jS];
	   if (j > -1){ /* column number is still positive; not accounted for yet */
	     S_diag_j[jS]  = -S_diag_j[jS]-1;
	   }
	 }
	 /* now the external part */
	 for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	   j = S_offd_j[jS];
	   if (j > -1){ /* column number is still positive; not accounted for yet */
	     S_offd_j[jS]  = -S_offd_j[jS]-1;
	   }
	 }
       }  

       /*---------------------------------------------
	* Now treat the case where point i is not in the
	* independent set: loop over
	* all the points j that influence equation i; if
	* j is a C point, then make i an F point.
	* If i is a new F point, then remove all the edges
        * from the graph for equation i.
	*---------------------------------------------*/

       else {

	 /* first the local part */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	   /* j is the column number, or the local number of the point influencing i */
	   j = S_diag_j[jS];
           if(j<0) j=-j-1;

	   if (CF_marker[j] > 0){ /* j is a C-point */
	     CF_marker[i] = F_PT;
	   }
	 }
	 /* now the external part */
	 for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	   j = S_offd_j[jS];
           if(j<0) j=-j-1;
	   if (CF_marker_offd[j] > 0){ /* j is a C-point */
	     CF_marker[i] = F_PT;
	   }
	 }

         /* remove all the edges for equation i if i is a new F point */
	 if (CF_marker[i] == F_PT){
	   /* first the local part */
	   for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	     j = S_diag_j[jS];
	     if (j > -1){ /* column number is still positive; not accounted for yet */
	       S_diag_j[jS]  = -S_diag_j[jS]-1;
	     }
	   }
	   /* now the external part */
	   for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	     j = S_offd_j[jS];
	     if (j > -1){ /* column number is still positive; not accounted for yet */
	       S_offd_j[jS]  = -S_offd_j[jS]-1;
	     }
	   }
	 }   
       } /* end else */
     } /* end first loop over graph */

     /* now communicate CF_marker to CF_marker_offd, to make
        sure that new external F points are known on this processor */

      /*------------------------------------------------
       * Exchange boundary data for CF_marker: send internal
         points to external points
       *------------------------------------------------*/

      index = 0;
      for (i = 0; i < num_sends; i++)
      {
        start = hypre_ParCSRCommPkgSendMapStart(comm_pkg, i);
        for (j = start; j < hypre_ParCSRCommPkgSendMapStart(comm_pkg, i+1); j++)
                int_buf_data[index++] 
                 = CF_marker[hypre_ParCSRCommPkgSendMapElmt(comm_pkg,j)];
      }
 
      if (num_procs > 1)
      {
      comm_handle = hypre_ParCSRCommHandleCreate(11, comm_pkg, int_buf_data, 
        CF_marker_offd);
 
      hypre_ParCSRCommHandleDestroy(comm_handle);   
      }

     /*---------------------------------------------
      * Now loop over the points i in the unassigned
      * graph again. For all points i that are no new C or
      * F points, remove the edges in equation i that
      * connect to C or F points.
      * (We have removed the rows for the new C and F
      * points above; now remove the columns.)
      *---------------------------------------------*/

     for (ig = 0; ig < graph_size; ig++) {
       i = graph_array[ig];

       if(CF_marker[i]==0) {

	 /* first the local part */
	 for (jS = S_diag_i[i]; jS < S_diag_i[i+1]; jS++) {
	   j = S_diag_j[jS];
           if(j<0) j=-j-1;

	   if (!CF_marker[j]==0 && S_diag_j[jS] > -1){ /* connection to C or F point, and
                                                 column number is still positive; not accounted for yet */
	     S_diag_j[jS]  = -S_diag_j[jS]-1;
	   }
	 }
	 /* now the external part */
	 for (jS = S_offd_i[i]; jS < S_offd_i[i+1]; jS++) {
	   j = S_offd_j[jS];
           if(j<0) j=-j-1;

	   if (!CF_marker_offd[j]==0 && S_offd_j[jS] > -1){ /* connection to C or F point, and
                                                 column number is still positive; not accounted for yet */
	     S_offd_j[jS]  = -S_offd_j[jS]-1;
	   }
	 }
       }
     } /* end second loop over graph */

     /*------------------------------------------------
      * Update subgraph
      *------------------------------------------------*/

     for (ig = 0; ig < graph_size; ig++) {
       i = graph_array[ig];
       
       if (!CF_marker[i]==0) /* C or F point */
	 {
	   /* the independent set subroutine needs measure 0 for
              removed nodes */
	   measure_array[i] = 0;
	   /* take point out of the subgraph */
	   graph_size--;
	   graph_array[ig] = graph_array[graph_size];
	   graph_array[graph_size] = i;
	   ig--;
	 }
     }
     for (ig = 0; ig < graph_offd_size; ig++) {
       i = graph_array_offd[ig];
       
       if (!CF_marker_offd[i]==0) /* C or F point */
	 {
	   /* the independent set subroutine needs measure 0 for
              removed nodes */
	   measure_array[i+num_variables] = 0;
	   /* take point out of the subgraph */
	   graph_offd_size--;
	   graph_array_offd[ig] = graph_array_offd[graph_offd_size];
	   graph_array_offd[graph_offd_size] = i;
	   ig--;
	 }
     }
     
   } /* end while */

   /*   printf("*** MIS iteration %d\n",iter);
   printf("graph_size remaining %d\n",graph_size);

   printf("num_cols_offd %d\n",num_cols_offd);
   for (i=0;i<num_variables;i++)
     {
              if(CF_marker[i]==1)
       printf("node %d CF %d\n",i,CF_marker[i]);
       }*/


   /*---------------------------------------------------
    * Clean up and return
    *---------------------------------------------------*/

   /* Reset S_matrix */
   for (i=0; i < S_diag_i[num_variables]; i++)
   {
      if (S_diag_j[i] < 0)
         S_diag_j[i] = -S_diag_j[i]-1;
   }
   for (i=0; i < S_offd_i[num_variables]; i++)
   {
      if (S_offd_j[i] < 0)
         S_offd_j[i] = -S_offd_j[i]-1;
   }
   /*for (i=0; i < num_variables; i++)
      if (CF_marker[i] == SF_PT) CF_marker[i] = F_PT;*/

   hypre_TFree(measure_array);

   hypre_TFree(measure_array);
   hypre_TFree(graph_array);
   if (num_cols_offd) hypre_TFree(graph_array_offd);
   hypre_TFree(buf_data);
   hypre_TFree(int_buf_data);
   hypre_TFree(CF_marker_offd);
   /*if (num_procs > 1) hypre_CSRMatrixDestroy(S_ext);*/

   *CF_marker_ptr   = CF_marker;

   return (ierr);
}
